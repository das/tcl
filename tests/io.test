# Functionality covered: operation of all IO commands, and all procedures
# defined in generic/tclIO.c.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands.  Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 1991-1994 The Regents of the University of California.
# Copyright (c) 1994-1997 Sun Microsystems, Inc.
#
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# SCCS: @(#) io.test 1.131 97/09/22 11:15:05

if {[string compare test [info procs test]] == 1} then {source defs}

if {"[info commands testchannel]" != "testchannel"} {
    puts "Skipping io tests. This application does not seem to have the"
    puts "testchannel command that is needed to run these tests."
    return
}

removeFile test1
removeFile pipe

# set up a long data file for some of the following tests

set f [open longfile w]
fconfigure $f -eofchar {} -translation lf
for { set i 0 } { $i < 100 } { incr i} {
    puts $f "#123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef0123456789abcdef
\#123456789abcdef01
\#"
    }
close $f

set f [open cat w]
puts $f {
    if {$argv == {}} {
	set argv -
    }
    foreach name $argv {
	if {$name == "-"} {
	    set f stdin
	} elseif {[catch {open $name r} f] != 0} {
	    puts stderr $f
	    continue
	}
	while {[eof $f] == 0} {
	    puts -nonewline stdout [read $f]
	}
	if {$f != "stdin"} {
	    close $f
	}
    }
}
close $f

# These tests are disabled until we decide what to do with "unsupported0".
#
#test io-1.7 {unsupported0 command} {
#    removeFile test1
#    set f1 [open iocmd.test]
#    set f2 [open test1 w]
#    unsupported0 $f1 $f2
#    close $f1
#    catch {close $f2}
#    set s1 [file size [info script]]
#    set s2 [file size test1]
#    set x ok
#    if {"$s1" != "$s2"} {
#        set x broken
#    }
#    set x
#} ok
#test io-1.8 {unsupported0 command} {
#    removeFile test1
#    set f1 [open [info script]]
#    set f2 [open test1 w]
#    unsupported0 $f1 $f2 40
#    close $f1
#    close $f2
#    file size test1
#} 40
#test io-1.9 {unsupported0 command} {
#    removeFile test1
#    set f1 [open [info script]]
#    set f2 [open test1 w]
#    unsupported0 $f1 $f2 -1
#    close $f1
#    close $f2
#    set x ok
#    set s1 [file size [info script]]
#    set s2 [file size test1]
#    if {$s1 != $s2} {
#        set x broken
#    }
#    set x
#} ok
#test io-1.10 {unsupported0 command} {unixOrPc} {
#    removeFile pipe
#    removeFile test1
#    set f1 [open pipe w]
#    puts $f1 {puts ready}
#    puts $f1 {gets stdin}
#    puts $f1 {set f1 [open [info script] r]}
#    puts $f1 {puts [read $f1 100]}
#    puts $f1 {close $f1}
#    close $f1
#    set f1 [open "|[list $tcltest pipe]" r+]
#    gets $f1
#    puts $f1 ready
#    flush $f1
#    set f2 [open test1 w]
#    set c [unsupported0 $f1 $f2 40]
#    catch {close $f1}
#    close $f2
#    set s1 [file size test1]
#    set x ok
#    if {$s1 != "40"} {
#        set x broken
#    }
#    list $c $x
#} {40 ok}

# Test standard handle management. The functions tested are
# Tcl_SetStdChannel and Tcl_GetStdChannel. Incidentally we are
# also testing channel table management.

if {$tcl_platform(platform) == "macintosh"} {
    set consoleFileNames [list console0 console1 console2]
} else {
    set consoleFileNames [lsort [testchannel open]]
}
test io-1.1 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
    set l ""
    lappend l [fconfigure stdin -buffering]
    lappend l [fconfigure stdout -buffering]
    lappend l [fconfigure stderr -buffering]
    lappend l [lsort [testchannel open]]
    set l
} [list line line none $consoleFileNames]
test io-1.2 {Tcl_SetStdChannel and Tcl_GetStdChannel} {
    interp create x
    set l ""
    lappend l [x eval {fconfigure stdin -buffering}]
    lappend l [x eval {fconfigure stdout -buffering}]
    lappend l [x eval {fconfigure stderr -buffering}]
    interp delete x
    set l
} {line line none}
test io-1.3 {Tcl_SetStdChannel & Tcl_GetStdChannel} {stdio} {
    set f [open test1 w]
    puts $f {
	close stdin
	close stdout
	close stderr
	set f [open test1 r]
	set f2 [open test2 w]
	set f3 [open test3 w]
	puts stdout [gets stdin]
	puts stdout out
	puts stderr err
	close $f
	close $f2
	close $f3
    }
    close $f
    set result [exec $tcltest test1]
    set f [open test2 r]
    set f2 [open test3 r]
    lappend result [read $f] [read $f2]
    close $f
    close $f2
    set result
} {{
out
} {err
}}
# This test relies on the fact that the smallest available fd is used first.
test io-1.4 {Tcl_SetStdChannel & Tcl_GetStdChannel} {unixOnly} {
    set f [open test1 w]
    puts $f { close stdin
	close stdout
	close stderr
	set f [open test1 r]
	set f2 [open test2 w]
	set f3 [open test3 w]
	puts stdout [gets stdin]
	puts stdout $f2
	puts stderr $f3
	close $f
	close $f2
	close $f3
    }
    close $f
    set result [exec $tcltest test1]
    set f [open test2 r]
    set f2 [open test3 r]
    lappend result [read $f] [read $f2]
    close $f
    close $f2
    set result
} {{ close stdin
file1
} {file2
}}
catch {interp delete z}
test io-1.5 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stdin
    catch {z eval flush stdin} msg1
    catch {z eval close stdin} msg2
    catch {z eval flush stdin} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{channel "stdin" wasn't opened for writing} {} {can not find channel named "stdin"}}
test io-1.6 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stdout
    catch {z eval flush stdout} msg1
    catch {z eval close stdout} msg2
    catch {z eval flush stdout} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{} {} {can not find channel named "stdout"}}
test io-1.7 {Tcl_GetChannel: stdio name translation} {
    interp create z
    eof stderr
    catch {z eval flush stderr} msg1
    catch {z eval close stderr} msg2
    catch {z eval flush stderr} msg3
    set result [list $msg1 $msg2 $msg3]
    interp delete z
    set result
} {{} {} {can not find channel named "stderr"}}
test io-1.8 {reuse of stdio special channels} {unixOnly} {
    removeFile script
    removeFile test1
    set f [open script w]
    puts $f {
	close stderr
	set f [open test1 w]
	puts stderr hello
	close $f
	set f [open test1 r]
	puts [gets $f]
    }
    close $f
    set f [open "|[list $tcltest script]" r]
    set c [gets $f]
    close $f
    set c
} hello
test io-1.9 {reuse of stdio special channels} {stdio} {
    removeFile script
    removeFile test1
    set f [open script w]
    puts $f {
	set f [open test1 w]
	puts $f hello
	close $f
	close stderr
	set f [open "|[list [info nameofexecutable] cat test1]" r]
	puts [gets $f]
    }
    close $f
    set f [open "|[list $tcltest script]" r]
    set c [gets $f]
    close $f
    set c
} hello

# Must add test function for testing Tcl_CreateCloseHandler and
# Tcl_DeleteCloseHandler.

# Test channel table management. The functions tested are
# GetChannelTable, DeleteChannelTable, Tcl_RegisterChannel,
# Tcl_UnregisterChannel, Tcl_GetChannel and Tcl_CreateChannel.
#
# These functions use "eof stdin" to ensure that the standard
# channels are added to the channel table of the interpreter.

test io-2.1 {GetChannelTable, DeleteChannelTable on std handles} {
    set l1 [testchannel refcount stdin]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stdin] - $l1]
    x eval {eof stdin}
    lappend l [expr [testchannel refcount stdin] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stdin] - $l1]
    set l
} {0 1 0}
test io-2.2 {GetChannelTable, DeleteChannelTable on std handles} {
    set l1 [testchannel refcount stdout]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stdout] - $l1]
    x eval {eof stdout}
    lappend l [expr [testchannel refcount stdout] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stdout] - $l1]
    set l
} {0 1 0}
test io-2.3 {GetChannelTable, DeleteChannelTable on std handles} {
    set l1 [testchannel refcount stderr]
    eof stdin
    interp create x
    set l ""
    lappend l [expr [testchannel refcount stderr] - $l1]
    x eval {eof stderr}
    lappend l [expr [testchannel refcount stderr] - $l1]
    interp delete x
    lappend l [expr [testchannel refcount stderr] - $l1]
    set l
} {0 1 0}
test io-2.4 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
    removeFile test1
    set l ""
    set f [open test1 w]
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-2.5 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
    removeFile test1
    set l ""
    set f [open test1 w]
    lappend l [lindex [testchannel info $f] 15]
    interp create x
    interp share "" $f x
    lappend l [lindex [testchannel info $f] 15]
    x eval close $f
    lappend l [lindex [testchannel info $f] 15]
    interp delete x
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 2 1 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-2.6 {Tcl_RegisterChannel, Tcl_UnregisterChannel} {
    removeFile test1
    set l ""
    set f [open test1 w]
    lappend l [lindex [testchannel info $f] 15]
    interp create x
    interp share "" $f x
    lappend l [lindex [testchannel info $f] 15]
    interp delete x
    lappend l [lindex [testchannel info $f] 15]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 1 2 1 [format "can not find channel named \"%s\"" $f]]
} 0
test io-2.7 {Tcl_GetChannel->Tcl_GetStdChannel, standard handles} {
    eof stdin
} 0
test io-2.8 {testing Tcl_GetChannel, user opened handle} {
    removeFile test1
    set f [open test1 w]
    set x [eof $f]
    close $f
    set x
} 0
test io-2.9 {Tcl_GetChannel, channel not found} {
    list [catch {eof file34} msg] $msg
} {1 {can not find channel named "file34"}}
test io-2.10 {Tcl_CreateChannel, insertion into channel table} {
    removeFile test1
    set f [open test1 w]
    set l ""
    lappend l [eof $f]
    close $f
    if {[catch {lindex [testchannel info $f] 15} msg]} {
	lappend l $msg
    } else {
	lappend l "very broken: $f found after being closed"
    }
    string compare [string tolower $l] \
	[list 0 [format "can not find channel named \"%s\"" $f]]
} 0

# Test management of attributes associated with a channel, such as
# its default translation, its name and type, etc. The functions
# tested in this group are Tcl_GetChannelName,
# Tcl_GetChannelType and Tcl_GetChannelFile. Tcl_GetChannelInstanceData
# not tested because files do not use the instance data.

test io-3.1 {Tcl_GetChannelName} {
    removeFile test1
    set f [open test1 w]
    set n [testchannel name $f]
    close $f
    string compare $n $f
} 0
test io-3.2 {Tcl_GetChannelType} {
    removeFile test1
    set f [open test1 w]
    set t [testchannel type $f]
    close $f
    string compare $t file
} 0
test io-3.3 {Tcl_GetChannelFile, input} {
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    puts $f "1234567890\n098765432"
    close $f
    set f [open test1 r]
    gets $f
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {10 11}
test io-3.4 {Tcl_GetChannelFile, output} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [tell $f]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [tell $f]
    close $f
    removeFile test1
    set l
} {6 6 0 6}

# Test flushing. The functions tested here are FlushChannel.

test io-4.1 {FlushChannel, no output buffered} {
    removeFile test1
    set f [open test1 w]
    flush $f
    set s [file size test1]
    close $f
    set s
} 0
test io-4.2 {FlushChannel, some output buffered} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    puts $f hello
    lappend l [file size test1]
    flush $f
    lappend l [file size test1]
    close $f
    lappend l [file size test1]
    set l
} {0 6 6}
test io-4.3 {FlushChannel, implicit flush on close} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    puts $f hello
    lappend l [file size test1]
    close $f
    lappend l [file size test1]
    set l
} {0 6}
test io-4.4 {FlushChannel, implicit flush when buffer fills} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    fconfigure $f -buffersize 60
    set l ""
    lappend l [file size test1]
    for {set i 0} {$i < 12} {incr i} {
	puts $f hello
    }
    lappend l [file size test1]
    flush $f
    lappend l [file size test1]
    close $f
    set l
} {0 60 72}
test io-4.5 {FlushChannel, implicit flush when buffer fills and on close} {unixOrPc} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -buffersize 60 -eofchar {}
    set l ""
    lappend l [file size test1]
    for {set i 0} {$i < 12} {incr i} {
	puts $f hello
    }
    lappend l [file size test1]
    close $f
    lappend l [file size test1]
    set l
} {0 60 72}
test io-4.6 {FlushChannel, async flushing, async close} {stdio && asyncPipeClose} {
    removeFile pipe
    removeFile output
    set f [open pipe w]
    puts $f {
	set f [open output w]
	fconfigure $f -translation lf -buffering none -eofchar {}
	while {![eof stdin]} {
	    after 20
	    puts -nonewline $f [read stdin 1024]
	}
	close $f
    }
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open output w]
    close $f
    set f [open "|[list $tcltest pipe]" w]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size output] < 65536) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result probably_broken
    } else {
        set result ok
    }
} ok

# Tests closing a channel. The functions tested are CloseChannel and Tcl_Close.

test io-5.1 {CloseChannel called when all references are dropped} {
    removeFile test1
    set f [open test1 w]
    interp create x
    interp share "" $f x
    set l ""
    lappend l [testchannel refcount $f]
    x eval close $f
    interp delete x
    lappend l [testchannel refcount $f]
    close $f
    set l
} {2 1}
test io-5.2 {CloseChannel called when all references are dropped} {
    removeFile test1
    set f [open test1 w]
    interp create x
    interp share "" $f x
    puts -nonewline $f abc
    close $f
    x eval puts $f def
    x eval close $f
    interp delete x
    set f [open test1 r]
    set l [gets $f]
    close $f
    set l
} abcdef
test io-5.3 {CloseChannel, not called before output queue is empty} {unixOrPc asyncPipeClose nonPortable tempNotPc} {
    removeFile pipe
    removeFile output
    set f [open pipe w]
    puts $f {

	# Need to not have eof char appended on close, because the other
	# side of the pipe already closed, so that writing would cause an
	# error "invalid file".

	fconfigure stdout -eofchar {}
	fconfigure stderr -eofchar {}

	set f [open output w]
	fconfigure $f -translation lf -buffering none
	for {set x 0} {$x < 20} {incr x} {
	    after 20
	    puts -nonewline $f [read stdin 1024]
	}
	close $f
    }
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open output w]
    close $f
    set f [open "|[list $tcltest pipe]" r+]
    fconfigure $f -blocking off -eofchar {}

    # Under windows, the first 24576 bytes of $x are copied to $f, and
    # then the writing fails.  

    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size output] < 20480) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result probably_broken
    } else {
        set result ok
    }
} ok
test io-5.4 {Tcl_Close} {
    removeFile test1
    set l ""
    lappend l [lsort [testchannel open]]
    set f [open test1 w]
    lappend l [lsort [testchannel open]]
    close $f
    lappend l [lsort [testchannel open]]
    set x [list $consoleFileNames \
		[lsort [eval list $consoleFileNames $f]] \
		$consoleFileNames]
    string compare $l $x
} 0
test io-5.5 {Tcl_Close vs standard handles} {unixOnly} {
    removeFile script
    set f [open script w]
    puts $f {
	close stdin
	puts [testchannel open]
    }
    close $f
    set f [open "|[list $tcltest script]" r]
    set l [gets $f]
    close $f
    set l
} {file1 file2}

# Test output on channels. The functions tested are Tcl_Write
# and Tcl_Flush.

test io-6.1 {Tcl_Write, channel not writable} {
    list [catch {puts stdin hello} msg] $msg
} {1 {channel "stdin" wasn't opened for writing}}
test io-6.2 {Tcl_Write, empty string} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -eofchar {}
    puts -nonewline $f ""
    close $f
    file size test1
} 0
test io-6.3 {Tcl_Write, nonempty string} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -eofchar {}
    puts -nonewline $f hello
    close $f
    file size test1
} 5
test io-6.4 {Tcl_Write, buffering in full buffering mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -buffering full -eofchar {}
    puts $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    close $f
    set l
} {6 0 0 6}
test io-6.5 {Tcl_Write, buffering in line buffering mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -buffering line -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    close $f
    set l
} {5 0 0 11}
test io-6.6 {Tcl_Write, buffering in no buffering mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -buffering none -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    close $f
    set l
} {0 5 0 11}
test io-6.7 {Tcl_Flush, full buffering} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -buffering full -eofchar {}
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    close $f
    set l
} {5 0 11 0 0 11}
test io-6.8 {Tcl_Flush, full buffering} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -buffering line
    puts -nonewline $f hello
    set l ""
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    puts $f hello
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    flush $f
    lappend l [testchannel outputbuffered $f]
    lappend l [file size test1]
    close $f
    set l
} {5 0 0 5 0 11 0 11}
test io-6.9 {Tcl_Flush, channel not writable} {
    list [catch {flush stdin} msg] $msg
} {1 {channel "stdin" wasn't opened for writing}}
test io-6.10 {Tcl_Write, looping and buffering} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    set f2 [open longfile r]
    for {set x 0} {$x < 10} {incr x} {
        puts $f1 [gets $f2]
    }
    close $f2
    close $f1
    file size test1
} 387
test io-6.11 {Tcl_Write, no newline, implicit flush} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -eofchar {}
    set f2 [open longfile r]
    for {set x 0} {$x < 10} {incr x} {
        puts -nonewline $f1 [gets $f2]
    }
    close $f1
    close $f2
    file size test1
} 377
test io-6.12 {Tcl_Write on a pipe} {stdio} {
    removeFile test1
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {
	set f1 [open longfile r]
	for {set x 0} {$x < 10} {incr x} {
	    puts [gets $f1]
	}
    }
    close $f1
    set f1 [open "|[list $tcltest pipe]" r]
    set f2 [open longfile r]
    set y ok
    for {set x 0} {$x < 10} {incr x} {
        set l1 [gets $f1]
        set l2 [gets $f2]
        if {"$l1" != "$l2"} {
            set y broken
        }
    }
    close $f1
    close $f2
    set y
} ok
test io-6.13 {Tcl_Write to a pipe, line buffered} {stdio} {
    removeFile test1
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {
	puts [gets stdin]
	puts [gets stdin]
    }
    close $f1
    set y ok
    set f1 [open "|[list $tcltest pipe]" r+]
    fconfigure $f1 -buffering line
    set f2 [open longfile r]
    set line [gets $f2]
    puts $f1 $line
    set backline [gets $f1]
    if {"$line" != "$backline"} {
        set y broken
    }
    set line [gets $f2]
    puts $f1 $line
    set backline [gets $f1]
    if {"$line" != "$backline"} {
        set y broken
    }
    close $f1
    close $f2
    set y
} ok
test io-6.14 {Tcl_Write, buffering and implicit flush at close} {
    removeFile test3
    set f [open test3 w]
    puts -nonewline $f "Text1"
    puts -nonewline $f " Text 2"
    puts $f " Text 3"
    close $f
    set f [open test3 r]
    set x [gets $f]
    close $f
    set x
} {Text1 Text 2 Text 3}
test io-6.15 {Tcl_Flush, channel not open for writing} {
    removeFile test1
    set fd [open test1 w]
    close $fd
    set fd [open test1 r]
    set x [list [catch {flush $fd} msg] $msg]
    close $fd
    string compare $x \
	[list 1 "channel \"$fd\" wasn't opened for writing"]
} 0
test io-6.16 {Tcl_Flush on pipe opened only for reading} {stdio} {
    set fd [open "|[list $tcltest cat longfile]" r]
    set x [list [catch {flush $fd} msg] $msg]
    catch {close $fd}
    string compare $x \
	[list 1 "channel \"$fd\" wasn't opened for writing"]
} 0
test io-6.17 {Tcl_Write buffers, then Tcl_Flush flushes} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    set x [file size test1]
    close $f1
    set x
} 18
test io-6.18 {Tcl_Write and Tcl_Flush intermixed} {
    removeFile test1
    set x ""
    set f1 [open test1 w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    lappend x [file size test1]
    puts $f1 hello
    flush $f1
    lappend x [file size test1]
    puts $f1 hello
    flush $f1
    lappend x [file size test1]
    close $f1
    set x
} {18 24 30}
test io-6.19 {Explicit and implicit flushes} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    set x ""
    puts $f1 hello
    puts $f1 hello
    puts $f1 hello
    flush $f1
    lappend x [file size test1]
    puts $f1 hello
    flush $f1
    lappend x [file size test1]
    puts $f1 hello
    close $f1
    lappend x [file size test1]
    set x
} {18 24 30}
test io-6.20 {Implicit flush when buffer is full} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    set line "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
    for {set x 0} {$x < 100} {incr x} {
      puts $f1 $line
    }
    set z ""
    lappend z [file size test1]
    for {set x 0} {$x < 100} {incr x} {
        puts $f1 $line
    }
    lappend z [file size test1]
    close $f1
    lappend z [file size test1]
    set z
} {4096 12288 12600}
test io-6.21 {Tcl_Flush to pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {set x [read stdin 6]}
    puts $f1 {set cnt [string length $x]}
    puts $f1 {puts "read $cnt characters"}
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    puts $f1 hello
    flush $f1
    set x [gets $f1]
    catch {close $f1}
    set x
} "read 6 characters"
test io-6.22 {Tcl_Flush called at other end of pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {
	fconfigure stdout -buffering full
	puts hello
	puts hello
	flush stdout
	gets stdin
	puts bye
	flush stdout
    }
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    set x ""
    lappend x [gets $f1]
    lappend x [gets $f1]
    puts $f1 hello
    flush $f1
    lappend x [gets $f1]
    close $f1
    set x
} {hello hello bye}
test io-6.23 {Tcl_Flush and line buffering at end of pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {
	puts hello
	puts hello
	gets stdin
	puts bye
    }
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    set x ""
    lappend x [gets $f1]
    lappend x [gets $f1]
    puts $f1 hello
    flush $f1
    lappend x [gets $f1]
    close $f1
    set x
} {hello hello bye}
test io-6.24 {Tcl_Write and Tcl_Flush move end of file} {
    set f [open test3 w]
    puts $f "Line 1"
    puts $f "Line 2"
    set f2 [open test3]
    set x {}
    lappend x [read -nonewline $f2]
    close $f2
    flush $f
    set f2 [open test3]
    lappend x [read -nonewline $f2]
    close $f2
    close $f
    set x
} {{} {Line 1
Line 2}}
test io-6.25 {Implicit flush with Tcl_Flush to command pipelines} {stdio} {
    removeFile test3
    set f [open "|[list $tcltest cat | $tcltest cat > test3]" w]
    puts $f "Line 1"
    puts $f "Line 2"
    close $f
    after 100
    set f [open test3 r]
    set x [read $f]
    close $f
    set x
} {Line 1
Line 2
}    
test io-6.26 {Tcl_Flush, Tcl_Write on bidirectional pipelines} {unixOrPc && unixExecs && tempNotPc} {
    set f [open "|[list cat -u]" r+]
    puts $f "Line1"
    flush $f
    set x [gets $f]
    close $f
    set x
} {Line1}
test io-6.27 {Tcl_Flush on closed pipeline} {stdio && tempNotPc} {
    removeFile pipe
    set f [open pipe w]
    puts $f {exit}
    close $f
    set f [open "|[list $tcltest pipe]" r+]
    gets $f
    puts $f output
    after 50
    #
    # The flush below will get a SIGPIPE. This is an expected part of
    # test and indicates that the test operates correctly. If you run
    # this test under a debugger, the signal will by intercepted unless
    # you disable the debugger's signal interception.
    #
    if {[catch {flush $f} msg]} {
	set x [list 1 $msg $errorCode]
	catch {close $f}
    } else {
	if {[catch {close $f} msg]} {
	    set x [list 1 $msg $errorCode]
	} else {
	    set x {this was supposed to fail and did not}
	}
    }
    regsub {".*":} $x {"":} x
    string tolower $x
} {1 {error flushing "": broken pipe} {posix epipe {broken pipe}}}
test io-6.28 {Tcl_Write, lf mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    puts $f hello\nthere\nand\nhere
    flush $f
    set s [file size test1]
    close $f
    set s
} 21
test io-6.29 {Tcl_Write, cr mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar {}
    puts $f hello\nthere\nand\nhere
    close $f
    file size test1
} 21
test io-6.30 {Tcl_Write, crlf mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar {}
    puts $f hello\nthere\nand\nhere
    close $f
    file size test1
} 25
test io-6.31 {Tcl_Write, background flush} {stdio} {
    removeFile pipe
    removeFile output
    set f [open pipe w]
    puts $f {set f [open output w]}
    puts $f {fconfigure $f -translation lf}
    set x [list while {![eof stdin]}]
    set x "$x {"
    puts $f $x
    puts $f {  puts -nonewline $f [read stdin 4096]}
    puts $f {  flush $f}
    puts $f "}"
    puts $f {close $f}
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open output w]
    close $f
    set f [open "|[list $tcltest pipe]" r+]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size output] < 65536) && ($counter < 1000)} {
        incr counter
        after 5
        update
    }
    if {$counter == 1000} {
        set result probably_broken
    } else {
        set result ok
    }
} ok
test io-6.32 {Tcl_Write, background flush to slow reader} {stdio && asyncPipeClose} {
    removeFile pipe
    removeFile output
    set f [open pipe w]
    puts $f {set f [open output w]}
    puts $f {fconfigure $f -translation lf}
    set x [list while {![eof stdin]}]
    set x "$x {"
    puts $f $x
    puts $f {  after 20}
    puts $f {  puts -nonewline $f [read stdin 1024]}
    puts $f {  flush $f}
    puts $f "}"
    puts $f {close $f}
    close $f
    set x 01234567890123456789012345678901
    for {set i 0} {$i < 11} {incr i} {
        set x "$x$x"
    }
    set f [open output w]
    close $f
    set f [open "|[list $tcltest pipe]" r+]
    fconfigure $f -blocking off
    puts -nonewline $f $x
    close $f
    set counter 0
    while {([file size output] < 65536) && ($counter < 1000)} {
        incr counter
        after 20
        update
    }
    if {$counter == 1000} {
        set result probably_broken
    } else {
        set result ok
    }
} ok
test io-6.33 {Tcl_Flush, implicit flush on exit} {stdio} {
    set f [open script w]
    puts $f {
	set f [open test1 w]
	fconfigure $f -translation lf
	puts $f hello
	puts $f bye
	puts $f strange
    }
    close $f
    exec $tcltest script
    set f [open test1 r]
    set r [read $f]
    close $f
    set r
} {hello
bye
strange
}

test io-6.34 {Tcl_Close, async flush on close, using sockets} {socket tempNotMac} {
    set c 0
    set x running
    set l abcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyzabcdefghijklmnopqrstuvwxyz
    proc writelots {s l} {
	for {set i 0} {$i < 2000} {incr i} {
	    puts $s $l
	}
    }
    proc accept {s a p} {
	global x
	fileevent $s readable [list readit $s]
	fconfigure $s -blocking off
	set x accepted
    }
    proc readit {s} {
	global c x
	set l [gets $s]
	
	if {[eof $s]} {
	    close $s
	    set x done
	} elseif {([string length $l] > 0) || ![fblocked $s]} {
	    incr c
	}
    }
    set ss [socket -server accept 2828]
    set cs [socket [info hostname] 2828]
    vwait x
    fconfigure $cs -blocking off
    writelots $cs $l
    close $cs
    close $ss
    vwait x
    set c
} 2000
test io-6.35 {Tcl_Close vs fileevent vs multiple interpreters} {socket} {
    catch {interp delete x}
    catch {interp delete y}
    interp create x
    interp create y
    set s [socket -server accept 2828]
    proc accept {s a p} {
	puts $s hello
	close $s
    }
    set c [socket [info hostname] 2828]
    interp share {} $c x
    interp share {} $c y
    close $c
    x eval {
	proc readit {s} {
	    gets $s
	    if {[eof $s]} {
		close $s
	    }
	}
    }
    y eval {
	proc readit {s} {
	    gets $s
	    if {[eof $s]} {
		close $s
	    }
	}
    }
    x eval "fileevent $c readable \{readit $c\}"
    y eval "fileevent $c readable \{readit $c\}"
    y eval [list close $c]
    update
    close $s
    interp delete x
    interp delete y
} ""

# Test end of line translations. Procedures tested are Tcl_Write, Tcl_Read.

test io-7.1 {Tcl_Write lf, Tcl_Read lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-7.2 {Tcl_Write lf, Tcl_Read cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-7.3 {Tcl_Write lf, Tcl_Read crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-7.4 {Tcl_Write cr, Tcl_Read cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-7.5 {Tcl_Write cr, Tcl_Read lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\rthere\rand\rhere\r"
test io-7.6 {Tcl_Write cr, Tcl_Read crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x 
} "hello\rthere\rand\rhere\r"
test io-7.7 {Tcl_Write crlf, Tcl_Read crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set x [read $f]
    close $f
    set x
} "hello\nthere\nand\nhere\n"
test io-7.8 {Tcl_Write crlf, Tcl_Read lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf
    set x [read $f]
    close $f
    set x
} "hello\r\nthere\r\nand\r\nhere\r\n"
test io-7.9 {Tcl_Write crlf, Tcl_Read cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr
    set x [read $f]
    close $f
    set x
} "hello\n\nthere\n\nand\n\nhere\n\n"
test io-7.10 {Tcl_Write lf, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}
test io-7.11 {Tcl_Write cr, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}
test io-7.12 {Tcl_Write crlf, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    set c [read $f]
    set x [fconfigure $f -translation]
    close $f
    list $c $x
} {{hello
there
and
here
} auto}

test io-7.13 {Tcl_Write crlf on block boundary, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set c [read $f]
    close $f
    string length $c
} [expr 700*15+1]

test io-7.14 {Tcl_Write crlf on block boundary, Tcl_Read crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set c [read $f]
    close $f
    string length $c
} [expr 700*15+1]

test io-7.15 {Tcl_Write mixed, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-7.16 {Tcl_Write ^Z at end, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\nand\rhere\n\x1a
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-7.17 {Tcl_Write, implicit ^Z at end, Tcl_Read auto} {pcOnly} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -eofchar \x1a -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set c [read $f]
    close $f
    set c
} {hello
there
and
here
}
test io-7.18 {Tcl_Write, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1 {} 1}
test io-7.19 {Tcl_Write, ^Z no newline in middle, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1 {} 1}
test io-7.20 {Tcl_Write, ^Z in middle ignored, Tcl_Read lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aghi 0 qrs 0 {} 1"
test io-7.21 {Tcl_Write, ^Z in middle ignored, Tcl_Read cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar {}
    set l ""
    set x [gets $f]
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs"]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {0 1 {} 1}
test io-7.22 {Tcl_Write, ^Z in middle ignored, Tcl_Read crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cghi\nqrs" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar {}
    set l ""
    set x [gets $f]
    lappend l [string compare $x "abc\ndef\n\x1aghi\nqrs"]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {0 1 {} 1}
test io-7.23 {Tcl_Write lf, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-7.24 {Tcl_Write lf, ^Z in middle, Tcl_Read lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-7.25 {Tcl_Write cr, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-7.26 {Tcl_Write cr, ^Z in middle, Tcl_Read cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-7.27 {Tcl_Write crlf, ^Z in middle, Tcl_Read auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}
test io-7.28 {Tcl_Write crlf, ^Z in middle, Tcl_Read crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set c [format abc\ndef\n%cqrs\ntuv 26]
    puts $f $c
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar \x1a
    set c [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $e
} {8 1}

# Test end of line translations. Functions tested are Tcl_Write and Tcl_Gets.

test io-8.1 {Tcl_Write lf, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 auto there 12 auto}
test io-8.2 {Tcl_Write cr, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 auto there 12 auto}
test io-8.3 {Tcl_Write crlf, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 7 auto there 14 auto}
test io-8.4 {Tcl_Write lf, Tcl_Gets lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    close $f
    set l
} {hello 6 lf there 12 lf}
test io-8.5 {Tcl_Write lf, Tcl_Gets cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {20 21 cr 1 {} 21 cr 1}
test io-8.6 {Tcl_Write lf, Tcl_Gets crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {20 21 crlf 1 {} 21 crlf 1}
test io-8.7 {Tcl_Write cr, Tcl_Gets cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 6 cr 0 there 12 cr 0}
test io-8.8 {Tcl_Write cr, Tcl_Gets lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 lf 1 {} 21 lf 1}
test io-8.9 {Tcl_Write cr, Tcl_Gets crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {21 21 crlf 1 {} 21 crlf 1}
test io-8.10 {Tcl_Write crlf, Tcl_Gets crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 7 crlf 0 there 14 crlf 0}
test io-8.11 {Tcl_Write crlf, Tcl_Gets cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr
    set l ""
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {hello 6 cr 0 6 13 cr 0}
test io-8.12 {Tcl_Write crlf, Tcl_Gets lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    puts $f hello\nthere\nand\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf
    set l ""
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    lappend l [string length [gets $f]]
    lappend l [tell $f]
    lappend l [fconfigure $f -translation]
    lappend l [eof $f]
    close $f
    set l
} {6 7 lf 0 6 14 lf 0}
test io-8.13 {binary mode is synonym of lf mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation binary
    set x [fconfigure $f -translation]
    close $f
    set x
} lf
#
# Test io-9.14 has been removed because "auto" output translation mode is
# not supoprted.
#
test io-8.14 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts $f hello\nthere\rand\r\nhere
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-8.15 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\r
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-8.16 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\n
    close $f
    set f [open test1 r]
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-8.17 {Tcl_Write mixed, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f hello\nthere\rand\r\nhere\r\n
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-8.18 {Tcl_Write ^Z at end, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "hello\nthere\nand\rhere\n\%c" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-8.19 {Tcl_Write, implicit ^Z at end, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -eofchar \x1a -translation lf
    puts $f hello\nthere\nand\rhere
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {hello there and here 0 {} 1}
test io-8.20 {Tcl_Write, ^Z in middle, Tcl_Gets auto, eofChar} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a
    fconfigure $f -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.21 {Tcl_Write, no newline ^Z in middle, Tcl_Gets auto, eofChar} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.22 {Tcl_Write, ^Z in middle ignored, Tcl_Gets lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-8.23 {Tcl_Write, ^Z in middle ignored, Tcl_Gets cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-8.24 {Tcl_Write, ^Z in middle ignored, Tcl_Gets crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar {}
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} "abc def 0 \x1aqrs 0 tuv 0 {} 1"
test io-8.25 {Tcl_Write lf, ^Z in middle, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.26 {Tcl_Write lf, ^Z in middle, Tcl_Gets lf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.27 {Tcl_Write cr, ^Z in middle, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.28 {Tcl_Write cr, ^Z in middle, Tcl_Gets cr} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.29 {Tcl_Write crlf, ^Z in middle, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.30 {Tcl_Write crlf, ^Z in middle, Tcl_Gets crlf} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar {}
    set s [format "abc\ndef\n%cqrs\ntuv" 26]
    puts $f $s
    close $f
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l ""
    lappend l [gets $f]
    lappend l [gets $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {abc def 0 {} 1}
test io-8.31 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 700} {incr i} {
	puts $f $line
    }
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set c ""
    while {[gets $f line] >= 0} {
	append c $line\n
    }
    close $f
    string length $c
} [expr 700*15+1]
test io-8.32 {Tcl_Write crlf on block boundary, Tcl_Gets auto} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set line "123456789ABCDE"	;# 14 char plus crlf
    puts -nonewline $f x	;# shift crlf across block boundary
    for {set i 0} {$i < 256} {incr i} {
	puts $f $line
    }
    close $f
    set f [open test1 r]
    fconfigure $f -translation auto
    set c ""
    while {[gets $f line] >= 0} {
	append c $line\n
    }
    close $f
    string length $c
} [expr 256*15+1]


# Test Tcl_Read and buffering.

test io-9.1 {Tcl_Read, channel not readable} {
    list [catch {read stdout} msg] $msg
} {1 {channel "stdout" wasn't opened for reading}}
test io-9.2 {Tcl_Read, zero byte count} {
    read stdin 0
} ""
test io-9.3 {Tcl_Read, negative byte count} {
    set f [open longfile r]
    set l [list [catch {read $f -1} msg] $msg]
    close $f
    set l
} {1 {bad argument "-1": should be "nonewline"}}
test io-9.4 {Tcl_Read, positive byte count} {
    set f [open longfile r]
    set x [read $f 1024]
    set s [string length $x]
    unset x
    close $f
    set s
} 1024
test io-9.5 {Tcl_Read, multiple buffers} {
    set f [open longfile r]
    fconfigure $f -buffersize 100
    set x [read $f 1024]
    set s [string length $x]
    unset x
    close $f
    set s
} 1024
test io-9.6 {Tcl_Read, very large read} {
    set f1 [open longfile r]
    set z [read $f1 1000000]
    close $f1
    set l [string length $z]
    set x ok
    set z [file size longfile]
    if {$z != $l} {
        set x broken
    }
    set x
} ok
test io-9.7 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
    set f1 [open longfile r]
    fconfigure $f1 -blocking off
    set z [read $f1 20]
    close $f1
    set l [string length $z]
    set x ok
    if {$l != 20} {
        set x broken
    }
    set x
} ok
test io-9.8 {Tcl_Read, nonblocking, file} {nonBlockFiles} {
    set f1 [open longfile r]
    fconfigure $f1 -blocking off
    set z [read $f1 1000000]
    close $f1
    set x ok
    set l [string length $z]]
    set z [file size longfile]]
    if {$z != $l} {
        set x broken
    }
  set x
} ok
test io-9.9 {Tcl_Read, read to end of file} {
    set f1 [open longfile r]
    set z [read $f1]
    close $f1
    set l [string length $z]
    set x ok
    set z [file size longfile]
    if {$z != $l} {
        set x broken
    }
    set x
} ok
test io-9.10 {Tcl_Read from a pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    puts $f1 hello
    flush $f1
    set x [read $f1]
    close $f1
    set x
} "hello\n"
test io-9.11 {Tcl_Read from a pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {puts [gets stdin]}
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    puts $f1 hello
    flush $f1
    set x ""
    lappend x [read $f1 6]
    puts $f1 hello
    flush $f1
    lappend x [read $f1]
    close $f1
    set x
} {{hello
} {hello
}}
test io-9.12 {Tcl_Read, -nonewline} {
    removeFile test1
    set f1 [open test1 w]
    puts $f1 hello
    puts $f1 bye
    close $f1
    set f1 [open test1 r]
    set c [read -nonewline $f1]
    close $f1
    set c
} {hello
bye}
test io-9.13 {Tcl_Read, -nonewline} {
    removeFile test1
    set f1 [open test1 w]
    puts $f1 hello
    puts $f1 bye
    close $f1
    set f1 [open test1 r]
    set c [read -nonewline $f1]
    close $f1
    list [string length $c] $c
} {9 {hello
bye}}
test io-9.14 {Tcl_Read, reading in small chunks} {
    removeFile test1
    set f [open test1 w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open test1]
    set x [list [read $f 1] [read $f 2] [read $f]]
    close $f
    set x
} {T wo { lines: this one
and this one
}}
test io-9.15 {Tcl_Read, asking for more input than available} {
    removeFile test1
    set f [open test1 w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open test1]
    set x [read $f 100]
    close $f
    set x
} {Two lines: this one
and this one
}
test io-9.16 {Tcl_Read, read to end of file with -nonewline} {
    removeFile test1
    set f [open test1 w]
    puts $f "Two lines: this one"
    puts $f "and this one"
    close $f
    set f [open test1]
    set x [read -nonewline $f]
    close $f
    set x
} {Two lines: this one
and this one}

# Test Tcl_Gets.

test io-10.1 {Tcl_Gets, reading what was written} {
    removeFile test1
    set f1 [open test1 w]
    set y "first line"
    puts $f1 $y
    close $f1
    set f1 [open test1 r]
    set x [gets $f1]
    set z ok
    if {"$x" != "$y"} {
        set z broken
    }
    close $f1
    set z
} ok
test io-10.2 {Tcl_Gets into variable} {
    set f1 [open longfile r]
    set c [gets $f1 x]
    set l [string length x]
    set z ok
    if {$l != $l} {
        set z broken
    }
    close $f1
    set z
} ok
test io-10.3 {Tcl_Gets from pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {puts [gets stdin]}
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    puts $f1 hello
    flush $f1
    set x [gets $f1]
    close $f1
    set z ok
    if {"$x" != "hello"} {
        set z broken
    }
    set z
} ok
test io-10.4 {Tcl_Gets with long line} {
    removeFile test3
    set f [open test3 w]
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    puts $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    close $f
    set f [open test3]
    set x [gets $f]
    close $f
    set x
} {abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
test io-10.5 {Tcl_Gets with long line} {
    set f [open test3]
    set x [gets $f y]
    close $f
    list $x $y
} {260 abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ}
test io-10.6 {Tcl_Gets and end of file} {
    removeFile test3
    set f [open test3 w]
    puts -nonewline $f "Test1\nTest2"
    close $f
    set f [open test3]
    set x {}
    set y {}
    lappend x [gets $f y] $y
    set y {}
    lappend x [gets $f y] $y
    set y {}
    lappend x [gets $f y] $y
    close $f
    set x
} {5 Test1 5 Test2 -1 {}}
test io-10.7 {Tcl_Gets and bad variable} {
    set f [open test3 w]
    puts $f "Line 1"
    puts $f "Line 2"
    close $f
    catch {unset x}
    set x 24
    set f [open test3 r]
    set result [list [catch {gets $f x(0)} msg] $msg]
    close $f
    set result
} {1 {can't set "x(0)": variable isn't array}}
test io-10.8 {Tcl_Gets, exercising double buffering} {
    set f [open test3 w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 100} {incr y} {puts $f $x}
    close $f
    set f [open test3 r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 100} {incr y} {gets $f}
    close $f
    set y
} 100
test io-10.9 {Tcl_Gets, exercising double buffering} {
    set f [open test3 w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 200} {incr y} {puts $f $x}
    close $f
    set f [open test3 r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 200} {incr y} {gets $f}
    close $f
    set y
} 200
test io-10.10 {Tcl_Gets, exercising double buffering} {
    set f [open test3 w]
    fconfigure $f -translation lf -eofchar {}
    set x ""
    for {set y 0} {$y < 99} {incr y} {set x "a$x"}
    for {set y 0} {$y < 300} {incr y} {puts $f $x}
    close $f
    set f [open test3 r]
    fconfigure $f -translation lf
    for {set y 0} {$y < 300} {incr y} {gets $f}
    close $f
    set y
} 300

# Test Tcl_Seek and Tcl_Tell.

test io-11.1 {Tcl_Seek to current position at start of file} {
    set f1 [open longfile r]
    seek $f1 0 current
    set c [tell $f1]
    close $f1
    set c
} 0
test io-11.2 {Tcl_Seek to offset from start} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 10 start
    set c [tell $f1]
    close $f1
    set c
} 10
test io-11.3 {Tcl_Seek to end of file} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 0 end
    set c [tell $f1]
    close $f1
    set c
} 54
test io-11.4 {Tcl_Seek to offset from end of file} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 -10 end
    set c [tell $f1]
    close $f1
    set c
} 44
test io-11.5 {Tcl_Seek to offset from current position} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 10 current
    seek $f1 10 current
    set c [tell $f1]
    close $f1
    set c
} 20
test io-11.6 {Tcl_Seek to offset from end of file} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 -10 end
    set c [tell $f1]
    set r [read $f1]
    close $f1
    list $c $r
} {44 {rstuvwxyz
}}
test io-11.7 {Tcl_Seek to offset from end of file, then to current position} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 -10 end
    set c1 [tell $f1]
    set r1 [read $f1 5]
    seek $f1 0 current
    set c2 [tell $f1]
    close $f1
    list $c1 $r1 $c2
} {44 rstuv 49}
test io-11.8 {Tcl_Seek on pipes: not supported} {stdio} {
    set f1 [open "|[list $tcltest]" r+]
    set x [list [catch {seek $f1 0 current} msg] $msg]
    close $f1
    regsub {".*":} $x {"":} x
    string tolower $x
} {1 {error during seek on "": invalid argument}}
test io-11.9 {Tcl_Seek, testing buffered input flushing} {
    removeFile test3
    set f [open test3 w]
    fconfigure $f -eofchar {}
    puts -nonewline $f "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ"
    close $f
    set f [open test3 RDWR]
    set x [read $f 1]
    seek $f 3
    lappend x [read $f 1]
    seek $f 0 start
    lappend x [read $f 1]
    seek $f 10 current
    lappend x [read $f 1]
    seek $f -2 end
    lappend x [read $f 1]
    seek $f 50 end
    lappend x [read $f 1]
    seek $f 1
    lappend x [read $f 1]
    close $f
    set x
} {a d a l Y {} b}
test io-11.10 {Tcl_Seek testing flushing of buffered input} {
    set f [open test3 w]
    fconfigure $f -translation lf
    puts $f xyz\n123
    close $f
    set f [open test3 r+]
    fconfigure $f -translation lf
    set x [gets $f]
    seek $f 0 current
    puts $f 456
    close $f
    list $x [viewFile test3]
} "xyz {xyz
456}"
test io-11.11 {Tcl_Seek testing flushing of buffered output} {
    set f [open test3 w]
    puts $f xyz\n123
    close $f
    set f [open test3 w+]
    puts $f xyzzy
    seek $f 2
    set x [gets $f]
    close $f
    list $x [viewFile test3]
} "zzy xyzzy"
test io-11.12 {Tcl_Seek testing combination of write, seek back and read} {
    set f [open test3 w]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyz\n123
    close $f
    set f [open test3 a+]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyzzy
    flush $f
    set x [tell $f]
    seek $f -4 cur
    set y [gets $f]
    close $f
    list $x [viewFile test3] $y
} {14 {xyz
123
xyzzy} zzy}
test io-11.13 {Tcl_Tell at start of file} {
    removeFile test1
    set f1 [open test1 w]
    set p [tell $f1]
    close $f1
    set p
} 0
test io-11.14 {Tcl_Tell after seek to end of file} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 0 end
    set c1 [tell $f1]
    close $f1
    set c1
} 54
test io-11.15 {Tcl_Tell combined with seeking} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -eofchar {}
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    puts $f1 "abcdefghijklmnopqrstuvwxyz"
    close $f1
    set f1 [open test1 r]
    seek $f1 10 start
    set c1 [tell $f1]
    seek $f1 10 current
    set c2 [tell $f1]
    close $f1
    list $c1 $c2
} {10 20}
test io-11.16 {Tcl_tell on pipe: always -1} {stdio} {
    set f1 [open "|[list $tcltest]" r+]
    set c [tell $f1]
    close $f1
    set c
} -1
test io-11.17 {Tcl_Tell on pipe: always -1} {stdio} {
    set f1 [open "|[list $tcltest]" r+]
    puts $f1 {puts hello}
    flush $f1
    set c [tell $f1]
    gets $f1
    close $f1
    set c
} -1
test io-11.18 {Tcl_Tell combined with seeking and reading} {
    removeFile test2
    set f [open test2 w]
    fconfigure $f -translation lf -eofchar {}
    puts -nonewline $f "line1\nline2\nline3\nline4\nline5\n"
    close $f
    set f [open test2]
    fconfigure $f -translation lf
    set x [tell $f]
    read $f 3
    lappend x [tell $f]
    seek $f 2
    lappend x [tell $f]
    seek $f 10 current
    lappend x [tell $f]
    seek $f 0 end
    lappend x [tell $f]
    close $f
    set x
} {0 3 2 12 30}
test io-11.19 {Tcl_Tell combined with opening in append mode} {
    set f [open test3 w]
    fconfigure $f -translation lf -eofchar {}
    puts $f "abcdefghijklmnopqrstuvwxyz"
    puts $f "abcdefghijklmnopqrstuvwxyz"
    close $f
    set f [open test3 a]
    set c [tell $f]
    close $f
    set c
} 54
test io-11.20 {Tcl_Tell combined with writing} {
    set f [open test3 w]
    set l ""
    seek $f 29 start
    lappend l [tell $f]
    puts -nonewline $f a
    seek $f 39 start
    lappend l [tell $f]
    puts -nonewline $f a
    lappend l [tell $f]
    seek $f 407 end
    lappend l [tell $f]
    close $f
    set l
} {29 39 40 447}

# Test Tcl_Eof

test io-12.1 {Tcl_Eof} {
    removeFile test1
    set f [open test1 w]
    puts $f hello
    puts $f hello
    close $f
    set f [open test1]
    set x [eof $f]
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    gets $f
    lappend x [eof $f]
    lappend x [eof $f]
    close $f
    set x
} {0 0 0 0 1 1}
test io-12.2 {Tcl_Eof with pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {gets stdin}
    puts $f1 {puts hello}
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    puts $f1 hello
    set x [eof $f1]
    flush $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    close $f1
    set x
} {0 0 0 1}
test io-12.3 {Tcl_Eof with pipe} {stdio} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {gets stdin}
    puts $f1 {puts hello}
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    puts $f1 hello
    set x [eof $f1]
    flush $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    gets $f1
    lappend x [eof $f1]
    close $f1
    set x
} {0 0 0 1 1 1}
test io-12.4 {Tcl_Eof, eof detection on nonblocking file} {nonBlockFiles} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    fconfigure $f -blocking off
    set l ""
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {{} 1}
test io-12.5 {Tcl_Eof, eof detection on nonblocking pipe} {stdio} {
    removeFile pipe
    set f [open pipe w]
    puts $f {
	exit
    }
    close $f
    set f [open "|[list $tcltest pipe]" r]
    set l ""
    lappend l [gets $f]
    lappend l [eof $f]
    close $f
    set l
} {{} 1}
test io-12.6 {Tcl_Eof, eof char, lf write, auto read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size test1]
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-12.7 {Tcl_Eof, eof char, lf write, lf read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size test1]
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-12.8 {Tcl_Eof, eof char, cr write, auto read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size test1]
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-12.9 {Tcl_Eof, eof char, cr write, cr read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size test1]
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {9 8 1}
test io-12.10 {Tcl_Eof, eof char, crlf write, auto read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size test1]
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {11 8 1}
test io-12.11 {Tcl_Eof, eof char, crlf write, crlf read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar \x1a
    puts $f abc\ndef
    close $f
    set s [file size test1]
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $s $l $e
} {11 8 1}
test io-12.12 {Tcl_Eof, eof char in middle, lf write, auto read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size test1]
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-12.13 {Tcl_Eof, eof char in middle, lf write, lf read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size test1]
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-12.14 {Tcl_Eof, eof char in middle, cr write, auto read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size test1]
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-12.15 {Tcl_Eof, eof char in middle, cr write, cr read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size test1]
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {17 8 1}
test io-12.16 {Tcl_Eof, eof char in middle, crlf write, auto read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size test1]
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {21 8 1}
test io-12.17 {Tcl_Eof, eof char in middle, crlf write, crlf read} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf -eofchar {}
    set i [format abc\ndef\n%cqrs\nuvw 26]
    puts $f $i
    close $f
    set c [file size test1]
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar \x1a
    set l [string length [read $f]]
    set e [eof $f]
    close $f
    list $c $l $e
} {21 8 1}

# Test Tcl_InputBlocked

test io-13.1 {Tcl_InputBlocked on nonblocking pipe} {unixOrPc tempNotPc} {
    set f1 [open "|[list $tcltest]" r+]
    puts $f1 {puts hello_from_pipe}
    flush $f1
    gets $f1
    fconfigure $f1 -blocking off -buffering full
    puts $f1 {puts hello}
    set x ""
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    flush $f1
    after 200
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    close $f1
    set x
} {{} 1 hello 0 {} 1}
test io-13.2 {Tcl_InputBlocked on blocking pipe} {unixOrPc tempNotPc} {
    set f1 [open "|[list $tcltest]" r+]
    fconfigure $f1 -buffering line
    puts $f1 {puts hello_from_pipe}
    set x ""
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    puts $f1 {exit}
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {hello_from_pipe 0 {} 0 1}
test io-13.3 {Tcl_InputBlocked vs files, short read} {
    removeFile test1
    set f [open test1 w]
    puts $f abcdefghijklmnop
    close $f
    set f [open test1 r]
    set l ""
    lappend l [fblocked $f]
    lappend l [read $f 3]
    lappend l [fblocked $f]
    lappend l [read -nonewline $f]
    lappend l [fblocked $f]
    lappend l [eof $f]
    close $f
    set l
} {0 abc 0 defghijklmnop 0 1}
test io-13.4 {Tcl_InputBlocked vs files, event driven read} {
    proc in {f} {
        global l x
	lappend l [read $f 3]
	if {[eof $f]} {lappend l eof; close $f; set x done}
    }
    removeFile test1
    set f [open test1 w]
    puts $f abcdefghijklmnop
    close $f
    set f [open test1 r]
    set l ""
    fileevent $f readable [list in $f]
    vwait x
    set l
} {abc def ghi jkl mno {p
} eof}
test io-13.5 {Tcl_InputBlocked vs files, short read, nonblocking} {nonBlockFiles} {
    removeFile test1
    set f [open test1 w]
    puts $f abcdefghijklmnop
    close $f
    set f [open test1 r]
    fconfigure $f -blocking off
    set l ""
    lappend l [fblocked $f]
    lappend l [read $f 3]
    lappend l [fblocked $f]
    lappend l [read -nonewline $f]
    lappend l [fblocked $f]
    lappend l [eof $f]
    close $f
    set l
} {0 abc 0 defghijklmnop 0 1}
test io-13.6 {Tcl_InputBlocked vs files, event driven read} {nonBlockFiles} {
    proc in {f} {
        global l x
	lappend l [read $f 3]
	if {[eof $f]} {lappend l eof; close $f; set x done}
    }
    removeFile test1
    set f [open test1 w]
    puts $f abcdefghijklmnop
    close $f
    set f [open test1 r]
    fconfigure $f -blocking off
    set l ""
    fileevent $f readable [list in $f]
    vwait x
    set l
} {abc def ghi jkl mno {p
} eof}

# Test Tcl_InputBuffered

test io-14.1 {Tcl_InputBuffered} {
    set f [open longfile r]
    fconfigure $f -buffersize 4096
    read $f 3
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {4093 3}
test io-14.2 {Tcl_InputBuffered, test input flushing on seek} {
    set f [open longfile r]
    fconfigure $f -buffersize 4096
    read $f 3
    set l ""
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    seek $f 0 current
    lappend l [testchannel inputbuffered $f]
    lappend l [tell $f]
    close $f
    set l
} {4093 3 0 3}

# Test Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize

test io-15.1 {Tcl_GetChannelBufferSize, default buffer size} {
    set f [open longfile r]
    set s [fconfigure $f -buffersize]
    close $f
    set s
} 4096
test io-15.2 {Tcl_SetChannelBufferSize, Tcl_GetChannelBufferSize} {
    set f [open longfile r]
    set l ""
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 10000
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 1
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize -1
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 0
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 100000
    lappend l [fconfigure $f -buffersize]
    fconfigure $f -buffersize 10000000
    lappend l [fconfigure $f -buffersize]
    close $f
    set l
} {4096 10000 4096 4096 4096 100000 4096}

# Test Tcl_SetChannelOption, Tcl_GetChannelOption

test io-16.1 {Tcl_GetChannelOption} {
    removeFile test1
    set f1 [open test1 w]
    set x [fconfigure $f1 -blocking]
    close $f1
    set x
} 1
#
# Test 17.2 was removed.
#
test io-16.2 {Tcl_GetChannelOption} {
    removeFile test1
    set f1 [open test1 w]
    set x [fconfigure $f1 -buffering]
    close $f1
    set x
} full
test io-16.3 {Tcl_GetChannelOption} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -buffering line
    set x [fconfigure $f1 -buffering]
    close $f1
    set x
} line
test io-16.4 {Tcl_GetChannelOption, Tcl_SetChannelOption} {
    removeFile test1
    set f1 [open test1 w]
    set l ""
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering line
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering none
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering line
    lappend l [fconfigure $f1 -buffering]
    fconfigure $f1 -buffering full
    lappend l [fconfigure $f1 -buffering]
    close $f1
    set l
} {full line none line full}
test io-16.5 {Tcl_GetChannelOption, invariance} {
    removeFile test1
    set f1 [open test1 w]
    set l ""
    lappend l [fconfigure $f1 -buffering]
    lappend l [list [catch {fconfigure $f1 -buffering green} msg] $msg]
    lappend l [fconfigure $f1 -buffering]
    close $f1
    set l
} {full {1 {bad value for -buffering: must be one of full, line, or none}} full}
test io-16.6 {Tcl_SetChannelOption, multiple options} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf -buffering line
    puts $f1 hello
    puts $f1 bye
    set x [file size test1]
    close $f1
    set x
} 10
test io-16.7 {Tcl_SetChannelOption, buffering, translation} {
    removeFile test1
    set f1 [open test1 w]
    fconfigure $f1 -translation lf
    puts $f1 hello
    puts $f1 bye
    set x ""
    fconfigure $f1 -buffering line
    lappend x [file size test1]
    puts $f1 really_bye
    lappend x [file size test1]
    close $f1
    set x
} {0 21}
test io-16.8 {Tcl_SetChannelOption, different buffering options} {
    removeFile test1
    set f1 [open test1 w]
    set l ""
    fconfigure $f1 -translation lf -buffering none -eofchar {}
    puts -nonewline $f1 hello
    lappend l [file size test1]
    puts -nonewline $f1 hello
    lappend l [file size test1]
    fconfigure $f1 -buffering full
    puts -nonewline $f1 hello
    lappend l [file size test1]
    fconfigure $f1 -buffering none
    lappend l [file size test1]
    puts -nonewline $f1 hello
    lappend l [file size test1]
    close $f1
    lappend l [file size test1]
    set l
} {5 10 10 10 20 20}
test io-16.9 {Tcl_SetChannelOption, blocking mode} {nonBlockFiles} {
    removeFile test1
    set f1 [open test1 w]
    close $f1
    set f1 [open test1 r]
    set x ""
    lappend x [fconfigure $f1 -blocking]
    fconfigure $f1 -blocking off
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [read $f1 1000]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {1 0 {} {} 0 1}
test io-16.10 {Tcl_SetChannelOption, blocking mode} {unixOrPc tempNotPc} {
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {gets stdin}
    puts $f1 {after 100}
    puts $f1 {puts hi}
    puts $f1 {gets stdin}
    close $f1
    set x ""
    set f1 [open "|[list $tcltest pipe]" r+]
    fconfigure $f1 -blocking off -buffering line
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    puts $f1 hello
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    puts $f1 bye
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    fconfigure $f1 -blocking on
    lappend x [fconfigure $f1 -blocking]
    lappend x [gets $f1]
    lappend x [fblocked $f1]
    lappend x [eof $f1]
    lappend x [gets $f1]
    lappend x [eof $f1]
    close $f1
    set x
} {0 {} 1 {} 1 {} 1 1 hi 0 0 {} 1}
test io-16.11 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -buffersize -10
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 4096
test io-16.12 {Tcl_SetChannelOption, Tcl_GetChannelOption buffer size} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -buffersize 10000000
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 4096
test io-16.13 {Tcl_SetChannelOption, Tcl_GetChannelOption, buffer size} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -buffersize 40000
    set x [fconfigure $f -buffersize]
    close $f
    set x
} 40000
test io-16.14 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server accept 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket localhost $port]
    update
    fconfigure $s2 -translation {auto lf}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto lf}
test io-16.15 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server accept 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket localhost $port]
    update
    fconfigure $s2 -translation {auto crlf}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto crlf}
test io-16.16 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server accept 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket localhost $port]
    update
    fconfigure $s2 -translation {auto cr}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto cr}
test io-16.17 {Tcl_SetChannelOption, setting read mode independently} \
	{socket} {
    proc accept {s a p} {close $s}
    set s1 [socket -server accept 0]
    set port [lindex [fconfigure $s1 -sockname] 2]
    set s2 [socket localhost $port]
    update
    fconfigure $s2 -translation {auto auto}
    set modes [fconfigure $s2 -translation]
    close $s1
    close $s2
    set modes
} {auto crlf}

test io-17.1 {POSIX open access modes: RDWR} {
    removeFile test3
    set f [open test3 w]
    puts $f xyzzy
    close $f
    set f [open test3 RDWR]
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [gets $f]
    close $f
    set f [open test3 r]
    lappend x [gets $f]
    close $f
    set x
} {zzy abzzy}
test io-17.2 {POSIX open access modes: CREAT} {unixOnly} {
    removeFile test3
    set f [open test3 {WRONLY CREAT} 0600]
    file stat test3 stats
    set x [format "0%o" [expr $stats(mode)&0777]]
    puts $f "line 1"
    close $f
    set f [open test3 r]
    lappend x [gets $f]
    close $f
    set x
} {0600 {line 1}}
test io-17.3 {POSIX open access modes: CREAT} {$testConfig(unix) && ([exec umask] == 2)} {
    # This test only works if your umask is 2, like ouster's.
    removeFile test3
    set f [open test3 {WRONLY CREAT}]
    close $f
    file stat test3 stats
    format "0%o" [expr $stats(mode)&0777]
} 0664
test io-17.4 {POSIX open access modes: CREAT} {
    removeFile test3
    set f [open test3 w]
    fconfigure $f -eofchar {}
    puts $f xyzzy
    close $f
    set f [open test3 {WRONLY CREAT}]
    fconfigure $f -eofchar {}
    puts -nonewline $f "ab"
    close $f
    set f [open test3 r]
    set x [gets $f]
    close $f
    set x
} abzzy
test io-17.5 {POSIX open access modes: APPEND} {
    removeFile test3
    set f [open test3 w]
    fconfigure $f -translation lf -eofchar {}
    puts $f xyzzy
    close $f
    set f [open test3 {WRONLY APPEND}]
    fconfigure $f -translation lf
    puts $f "new line"
    seek $f 0
    puts $f "abc"
    close $f
    set f [open test3 r]
    fconfigure $f -translation lf
    set x ""
    seek $f 6 current
    lappend x [gets $f]
    lappend x [gets $f]
    close $f
    set x
} {{new line} abc}
test io-17.6 {POSIX open access modes: EXCL} {
    removeFile test3
    set f [open test3 w]
    puts $f xyzzy
    close $f
    set msg [list [catch {open test3 {WRONLY CREAT EXCL}} msg] $msg]
    regsub " already " $msg " " msg
    string tolower $msg
} {1 {couldn't open "test3": file exists}}
test io-17.7 {POSIX open access modes: EXCL} {
    removeFile test3
    set f [open test3 {WRONLY CREAT EXCL}]
    fconfigure $f -eofchar {}
    puts $f "A test line"
    close $f
    viewFile test3
} {A test line}
test io-17.8 {POSIX open access modes: TRUNC} {
    removeFile test3
    set f [open test3 w]
    puts $f xyzzy
    close $f
    set f [open test3 {WRONLY TRUNC}]
    puts $f abc
    close $f
    set f [open test3 r]
    set x [gets $f]
    close $f
    set x
} abc
test io-17.9 {POSIX open access modes: NONBLOCK} {nonPortable macOrUnix} {
    removeFile test3
    set f [open test3 {WRONLY NONBLOCK CREAT}]
    puts $f "NONBLOCK test"
    close $f
    set f [open test3 r]
    set x [gets $f]
    close $f
    set x
} {NONBLOCK test}
test io-17.10 {POSIX open access modes: RDONLY} {
    set f [open test1 w]
    puts $f "two lines: this one"
    puts $f "and this"
    close $f
    set f [open test1 RDONLY]
    set x [list [gets $f] [catch {puts $f Test} msg] $msg]
    close $f
    string compare [string tolower $x] \
	[list {two lines: this one} 1 \
		[format "channel \"%s\" wasn't opened for writing" $f]]
} 0
test io-17.11 {POSIX open access modes: RDONLY} {
    removeFile test3
    string tolower [list [catch {open test3 RDONLY} msg] $msg]
} {1 {couldn't open "test3": no such file or directory}}
test io-17.12 {POSIX open access modes: WRONLY} {
    removeFile test3
    string tolower [list [catch {open test3 WRONLY} msg] $msg]
} {1 {couldn't open "test3": no such file or directory}}
test io-17.13 {POSIX open access modes: WRONLY} {
    makeFile xyzzy test3
    set f [open test3 WRONLY]
    fconfigure $f -eofchar {}
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [list [catch {gets $f} msg] $msg]
    close $f
    lappend x [viewFile test3]
    string compare [string tolower $x] \
	[list 1 "channel \"$f\" wasn't opened for reading" abzzy]
} 0
test io-17.14 {POSIX open access modes: RDWR} {
    removeFile test3
    string tolower [list [catch {open test3 RDWR} msg] $msg]
} {1 {couldn't open "test3": no such file or directory}}
test io-17.15 {POSIX open access modes: RDWR} {
    makeFile xyzzy test3
    set f [open test3 RDWR]
    puts -nonewline $f "ab"
    seek $f 0 current
    set x [gets $f]
    close $f
    lappend x [viewFile test3]
} {zzy abzzy}
if {![file exists ~/_test_] && [file writable ~]} {
    test io-17.16 {tilde substitution in open} {
	set f [open ~/_test_ w]
	puts $f "Some text"
	close $f
	set x [file exists [file join $env(HOME) _test_]]
	removeFile [file join $env(HOME) _test_]
	set x
    } 1
}
test io-17.17 {tilde substitution in open} {
    set home $env(HOME)
    unset env(HOME)
    set x [list [catch {open ~/foo} msg] $msg]
    set env(HOME) $home
    set x
} {1 {couldn't find HOME environment variable to expand path}}

test io-18.1 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent foo} msg] $msg
} {1 {wrong # args: must be "fileevent channelId event ?script?}}
test io-18.2 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent foo bar baz q} msg] $msg
} {1 {wrong # args: must be "fileevent channelId event ?script?}}
test io-18.3 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent gorp readable} msg] $msg
} {1 {can not find channel named "gorp"}}
test io-18.4 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent gorp writable} msg] $msg
} {1 {can not find channel named "gorp"}}
test io-18.5 {Tcl_FileeventCmd: errors} {
    list [catch {fileevent gorp who-knows} msg] $msg
} {1 {bad event name "who-knows": must be readable or writable}}

#
# Test fileevent on a file
#

set f [open foo w+]

test io-19.1 {Tcl_FileeventCmd: creating, deleting, querying} {
    list [fileevent $f readable] [fileevent $f writable]
} {{} {}}
test io-19.2 {Tcl_FileeventCmd: replacing} {
    set result {}
    fileevent $f r "first script"
    lappend result [fileevent $f readable]
    fileevent $f r "new script"
    lappend result [fileevent $f readable]
    fileevent $f r "yet another"
    lappend result [fileevent $f readable]
    fileevent $f r ""
    lappend result [fileevent $f readable]
} {{first script} {new script} {yet another} {}}

#
# Test fileevent on a pipe
#

if {($tcl_platform(platform) != "macintosh") && \
	($testConfig(unixExecs) == 1)} {

catch {set f2 [open "|[list cat -u]" r+]}
catch {set f3 [open "|[list cat -u]" r+]}

test io-20.1 {Tcl_FileeventCmd: creating, deleting, querying} {
    set result {}
    fileevent $f readable "script 1"
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f writable "write script"
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f readable {}
    lappend result [fileevent $f readable] [fileevent $f writable]
    fileevent $f writable {}
    lappend result [fileevent $f readable] [fileevent $f writable]
} {{script 1} {} {script 1} {write script} {} {write script} {} {}}
test io-20.2 {Tcl_FileeventCmd: deleting when many present} {
    set result {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f r "read f"
    fileevent $f2 r "read f2"
    fileevent $f3 r "read f3"
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f2 r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f3 r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
    fileevent $f r {}
    lappend result [fileevent $f r] [fileevent $f2 r] [fileevent $f3 r]
} {{} {} {} {read f} {read f2} {read f3} {read f} {} {read f3} {read f} {} {} {} {} {}}

test io-21.1 {FileEventProc procedure: normal read event} {
    fileevent $f2 readable {
	set x [gets $f2]; fileevent $f2 readable {}
    }
    puts $f2 text; flush $f2
    set x initial
    vwait x
    set x
} {text}
test io-21.2 {FileEventProc procedure: error in read event} {
    proc bgerror args {
	global x
	set x $args
    }
    fileevent $f2 readable {error bogus}
    puts $f2 text; flush $f2
    set x initial
    vwait x
    rename bgerror {}
    list $x [fileevent $f2 readable]
} {bogus {}}
test io-21.3 {FileEventProc procedure: normal write event} {
    fileevent $f2 writable {
	lappend x "triggered"
	incr count -1
	if {$count <= 0} {
	    fileevent $f2 writable {}
	}
    }
    set x initial
    set count 3
    vwait x
    vwait x
    vwait x
    set x
} {initial triggered triggered triggered}
test io-21.4 {FileEventProc procedure: eror in write event} {
    proc bgerror args {
	global x
	set x $args
    }
    fileevent $f2 writable {error bad-write}
    set x initial
    vwait x
    rename bgerror {}
    list $x [fileevent $f2 writable]
} {bad-write {}}
test io-21.5 {FileEventProc procedure: end of file} {unixOrPc} {
    set f4 [open "|[list $tcltest cat << foo]" r]
    fileevent $f4 readable {
	if {[gets $f4 line] < 0} {
	    lappend x eof
	    fileevent $f4 readable {}
	} else {
	    lappend x $line
	}
    }
    set x initial
    vwait x
    vwait x
    close $f4
    set x
} {initial foo eof}

catch {close $f2}
catch {close $f3}

}
	# Closes if {($platform(platform) != "macintosh") && \
	#		($testConfig(unixExecs) == 1)} clause

close $f
makeFile "foo bar" foo
test io-22.1 {DeleteFileEvent, cleanup on close} {
    set f [open foo r]
    fileevent $f readable {
	lappend x "binding triggered: \"[gets $f]\""
	fileevent $f readable {}
    }
    close $f
    set x initial
    after 100 { set y done }
    vwait y
    set x
} {initial}
test io-22.2 {DeleteFileEvent, cleanup on close} {
    set f [open foo r]
    set f2 [open foo r]
    fileevent $f readable {
	    lappend x "f triggered: \"[gets $f]\""
	    fileevent $f readable {}
	}
    fileevent $f2 readable {
	lappend x "f2 triggered: \"[gets $f2]\""
	fileevent $f2 readable {}
    }
    close $f
    set x initial
    vwait x
    close $f2
    set x
} {initial {f2 triggered: "foo bar"}}
test io-22.3 {DeleteFileEvent, cleanup on close} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
    fileevent $f readable {f script}
    fileevent $f2 readable {f2 script}
    fileevent $f3 readable {f3 script}
    set x {}
    close $f2
    lappend x [catch {fileevent $f readable} msg] $msg \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable} msg] $msg
    close $f3
    lappend x [catch {fileevent $f readable} msg] $msg \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable}]
    close $f
    lappend x [catch {fileevent $f readable}] \
	    [catch {fileevent $f2 readable}] \
	    [catch {fileevent $f3 readable}]
} {0 {f script} 1 0 {f3 script} 0 {f script} 1 1 1 1 1}

# Execute these tests only if the "testfevent" command is present.

if {[info commands testfevent] == "testfevent"} {

test io-23.1 {Tcl event loop vs multiple interpreters} {
    testfevent create
    testfevent cmd {
        set f [open foo r]
        set x "no event"
        fileevent $f readable {
            set x "f triggered: [gets $f]"
            fileevent $f readable {}
        }
    } 
    after 1	;# We must delay because Windows takes a little time to notice
    update
    testfevent cmd {close $f}
    list [testfevent cmd {set x}] [testfevent cmd {info commands after}]
} {{f triggered: foo bar} after}
test io-23.2 {Tcl event loop vs multiple interpreters} {
    testfevent create
    testfevent cmd {
        set x 0
        after 100 {set x triggered}
        vwait x
        set x
    }
} {triggered}
test io-23.3 {Tcl event loop vs multiple interpreters} {
    testfevent create
    testfevent cmd {
        set x 0
        after 10 {lappend x timer}
        after 30
        set result $x
        update idletasks
        lappend result $x
        update
        lappend result $x
    }
} {0 0 {0 timer}}

test io-24.1 {fileevent vs multiple interpreters} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
    fileevent $f readable {script 1}
    testfevent create
    testfevent share $f2
    testfevent cmd "fileevent $f2 readable {script 2}"
    fileevent $f3 readable {sript 3}
    set x {}
    lappend x [fileevent $f2 readable]
    testfevent delete
    lappend x [fileevent $f readable] [fileevent $f2 readable] \
        [fileevent $f3 readable]
    close $f
    close $f2
    close $f3
    set x
} {{} {script 1} {} {sript 3}}
test io-24.2 {deleting fileevent on interpreter delete} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
    set f4 [open foo r]
    fileevent $f readable {script 1}
    testfevent create
    testfevent share $f2
    testfevent share $f3
    testfevent cmd "fileevent $f2 readable {script 2}
        fileevent $f3 readable {script 3}"
    fileevent $f4 readable {script 4}
    testfevent delete
    set x [list [fileevent $f readable] [fileevent $f2 readable] \
                [fileevent $f3 readable] [fileevent $f4 readable]]
    close $f
    close $f2
    close $f3
    close $f4
    set x
} {{script 1} {} {} {script 4}}
test io-24.3 {deleting fileevent on interpreter delete} {
    set f [open foo r]
    set f2 [open foo r]
    set f3 [open foo r]
    set f4 [open foo r]
    testfevent create
    testfevent share $f3
    testfevent share $f4
    fileevent $f readable {script 1}
    fileevent $f2 readable {script 2}
    testfevent cmd "fileevent $f3 readable {script 3}
      fileevent $f4 readable {script 4}"
    testfevent delete
    set x [list [fileevent $f readable] [fileevent $f2 readable] \
                [fileevent $f3 readable] [fileevent $f4 readable]]
    close $f
    close $f2
    close $f3
    close $f4
    set x
} {{script 1} {script 2} {} {}}
test io-24.4 {file events on shared files and multiple interpreters} {
    set f [open foo r]
    set f2 [open foo r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    fileevent $f2 readable {script 3}
    set x [list [fileevent $f2 readable] \
                [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    close $f2
    set x
} {{script 3} {script 1} {script 2}}
test io-24.5 {file events on shared files, deleting file events} {
    set f [open foo r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    testfevent cmd "fileevent $f readable {}"
    set x [list [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    set x
} {{} {script 2}}
test io-24.6 {file events on shared files, deleting file events} {
    set f [open foo r]
    testfevent create
    testfevent share $f
    testfevent cmd "fileevent $f readable {script 1}"
    fileevent $f readable {script 2}
    fileevent $f readable {}
    set x [list [testfevent cmd "fileevent $f readable"] \
                [fileevent $f readable]]
    testfevent delete
    close $f
    set x
} {{script 1} {}}

}

# The above curly closes the test for presence of the "testfevent" command.

test io-25.1 {testing readability conditions} {
    set f [open bar w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open bar r]
    fileevent $f readable [list consume $f]
    proc consume {f} {
	global x l
	lappend l called
	if {[eof $f]} {
	    close $f
	    set x done
	} else {
	    gets $f
	}
    }
    set l ""
    set x not_done
    vwait x
    list $x $l
} {done {called called called called called called called}}
test io-25.2 {testing readability conditions} {nonBlockFiles} {
    set f [open bar w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open bar r]
    fileevent $f readable [list consume $f]
    fconfigure $f -blocking off
    proc consume {f} {
	global x l
	lappend l called
	if {[eof $f]} {
	    close $f
	    set x done
	} else {
	    gets $f
	}
    }
    set l ""
    set x not_done
    vwait x
    list $x $l
} {done {called called called called called called called}}
test io-25.3 {testing readability conditions} {unixOnly nonBlockFiles} {
    set f [open bar w]
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    puts $f abcdefg
    close $f
    set f [open my_script w]
    puts $f {
	proc copy_slowly {f} {
	    while {![eof $f]} {
		puts [gets $f]
		after 200
	    }
	    close $f
	}
    }
    close $f
    set f [open "|[list $tcltest]" r+]
    fileevent $f readable [list consume $f]
    fconfigure $f -buffering line
    fconfigure $f -blocking off
    proc consume {f} {
	global x l
	if {[eof $f]} {
	    set x done
	} else {
	    gets $f
	    lappend l [fblocked $f]
	    gets $f
	    lappend l [fblocked $f]
	}
    }
    set l ""
    set x not_done
    puts $f {source my_script}
    puts $f {set f [open bar r]}
    puts $f {copy_slowly $f}
    puts $f {exit}
    vwait x
    close $f
    list $x $l
} {done {0 1 0 1 0 1 0 1 0 1 0 1 0 0}}
test io-25.4 {lf write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.5 {lf write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.6 {cr write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.7 {cr write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.8 {crlf write, testing readability, ^Z termination, auto read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -translation auto -eofchar \x1a
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.9 {crlf write, testing readability, ^Z in middle, auto read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation auto
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.10 {lf write, testing readability, ^Z in middle, lf read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation lf
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.11 {lf write, testing readability, ^Z termination, lf read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -translation lf -eofchar \x1a
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.12 {cr write, testing readability, ^Z in middle, cr read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation cr
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.13 {cr write, testing readability, ^Z termination, cr read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation cr
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -translation cr -eofchar \x1a
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.14 {crlf write, testing readability, ^Z in middle, crlf read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%cfoo\nbar\n" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -eofchar \x1a -translation crlf
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}
test io-25.15 {crlf write, testing readability, ^Z termi, crlf read mode} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation crlf
    set c [format "abc\ndef\n%c" 26]
    puts -nonewline $f $c
    close $f
    proc consume {f} {
	global c x l
	if {[eof $f]} {
	   set x done
	   close $f
	} else {
	   lappend l [gets $f]
	   incr c
	}
    }
    set c 0
    set l ""
    set f [open test1 r]
    fconfigure $f -translation crlf -eofchar \x1a
    fileevent $f readable [list consume $f]
    vwait x
    list $c $l
} {3 {abc def {}}}

test io-26.1 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open test1 r]
    set l ""
    lappend l [file size test1]
    fconfigure $f -translation crlf
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [read $f 1]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 1]
    lappend l [eof $f]
    close $f
    set l
} "7 a 1 [list \r] 2 b 3 [list \r] 4 c 5 {
} 7 0 {} 1"
test io-26.2 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open test1 r]
    set l ""
    lappend l [file size test1]
    fconfigure $f -translation crlf
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 2]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\r] 2 [list b\r] 4 [list c\n] 7 0 {} 7 1"
test io-26.3 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open test1 r]
    set l ""
    lappend l [file size test1]
    fconfigure $f -translation crlf
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\rb] 3 [list \rc\n] 7 0 {} 7 1"
test io-26.4 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open test1 r]
    set l ""
    lappend l [file size test1]
    fconfigure $f -translation crlf
    lappend l [read $f 3]
    lappend l [tell $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} "7 [list a\rb] 3 [list \rc] 7 0 {} 7 1"
test io-26.5 {testing crlf reading, leftover cr disgorgment} {
    removeFile test1
    set f [open test1 w]
    fconfigure $f -translation lf
    puts -nonewline $f "a\rb\rc\r\n"
    close $f
    set f [open test1 r]
    set l ""
    lappend l [file size test1]
    fconfigure $f -translation crlf
    lappend l [set x [gets $f]]
    lappend l [tell $f]
    lappend l [gets $f]
    lappend l [tell $f]
    lappend l [eof $f]
    close $f
    set l
} [list 7 a\rb\rc 7 {} 7 1]
    
test io-27.1 {testing handler deletion} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    testchannelevent $f add readable [list delhandler $f]
    proc delhandler {f} {
	global z
	set z called
	testchannelevent $f delete 0
    }
    set z not_called
    update
    close $f
    set z
} called
test io-27.2 {testing handler deletion with multiple handlers} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    testchannelevent $f add readable [list delhandler $f 1]
    testchannelevent $f add readable [list delhandler $f 0]
    proc delhandler {f i} {
	global z
	lappend z "called delhandler $f $i"
	testchannelevent $f delete 0
    }
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	[list [list called delhandler $f 0] [list called delhandler $f 1]]
} 0
test io-27.3 {testing handler deletion with multiple handlers} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    testchannelevent $f add readable [list notcalled $f 1]
    testchannelevent $f add readable [list delhandler $f 0]
    set z ""
    proc notcalled {f i} {
	global z
	lappend z "notcalled was called!! $f $i"
    }
    proc delhandler {f i} {
	global z
	testchannelevent $f delete 1
	lappend z "delhandler $f $i called"
	testchannelevent $f delete 0
	lappend z "delhandler $f $i deleted myself"
    }
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	[list [list delhandler $f 0 called] \
	      [list delhandler $f 0 deleted myself]]
} 0
test io-27.4 {testing handler deletion vs reentrant calls} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    testchannelevent $f add readable [list delrecursive $f]
    proc delrecursive {f} {
	global z u
	if {"$u" == "recursive"} {
	    testchannelevent $f delete 0
	    lappend z "delrecursive deleting recursive"
	} else {
	    lappend z "delrecursive calling recursive"
	    set u recursive
	    update
	}
    }
    set u toplevel
    set z ""
    update
    close $f
    string compare [string tolower $z] \
	{{delrecursive calling recursive} {delrecursive deleting recursive}}
} 0
test io-27.5 {testing handler deletion vs reentrant calls} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    testchannelevent $f add readable [list notcalled $f]
    testchannelevent $f add readable [list del $f]
    proc notcalled {f} {
	global z
	lappend z "notcalled was called!! $f"
    }
    proc del {f} {
	global z u
	if {"$u" == "recursive"} {
	    testchannelevent $f delete 1
	    testchannelevent $f delete 0
	    lappend z "del deleted notcalled"
	    lappend z "del deleted myself"
	} else {
	    set u recursive
	    lappend z "del calling recursive"
	    update
	    lappend z "del after update"
	}
    }
    set z ""
    set u toplevel
    update
    close $f
    string compare [string tolower $z] \
	[list {del calling recursive} {del deleted notcalled} \
	      {del deleted myself} {del after update}]
} 0
test io-27.6 {testing handler deletion vs reentrant calls} {
    removeFile test1
    set f [open test1 w]
    close $f
    set f [open test1 r]
    testchannelevent $f add readable [list second $f]
    testchannelevent $f add readable [list first $f]
    proc first {f} {
	global u z
	if {"$u" == "toplevel"} {
	    lappend z "first called"
	    set u first
	    update
	    lappend z "first after update"
	} else {
	    lappend z "first called not toplevel"
	}
    }
    proc second {f} {
	global u z
	if {"$u" == "first"} {
	    lappend z "second called, first time"
	    set u second
	    testchannelevent $f delete 0
	} elseif {"$u" == "second"} {
	    lappend z "second called, second time"
	    testchannelevent $f delete 0
	} else {
	    lappend z "second called, cannot happen!"
	    testchannelevent $f removeall
	}
    }
    set z ""
    set u toplevel
    update
    close $f
    string compare [string tolower $z] \
	[list {first called} {first called not toplevel} \
	      {second called, first time} {second called, second time} \
	      {first after update}]
} 0

test io-28.1 {Test old socket deletion on Macintosh} {socket} {
    set x 0
    set result ""
    proc accept {s a p} {
	global x wait
	fconfigure $s -blocking off
	puts $s "sock[incr x]"
	close $s
	set wait done
    }
    set ss [socket -server accept 2831]
    set wait ""
    set cs [socket [info hostname] 2831]
    vwait wait
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] 2831]
    vwait wait
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] 2831]
    vwait wait
    lappend result [gets $cs]
    close $cs

    set wait ""
    set cs [socket [info hostname] 2831]
    vwait wait
    lappend result [gets $cs]
    close $cs
    close $ss
    set result
} {sock1 sock2 sock3 sock4}

test io-29.1 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fcopy $f1 $f2 -command { # }
    catch { fcopy $f1 $f2 } msg
    close $f1
    close $f2
    string compare $msg "channel \"$f1\" is busy"
} {0}
test io-29.2 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    set f3 [open [info script]]
    fcopy $f1 $f2 -command { # }
    catch { fcopy $f3 $f2 } msg
    close $f1
    close $f2
    close $f3
    string compare $msg "channel \"$f2\" is busy"
} {0}
test io-29.3 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    set s0 [fcopy $f1 $f2]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size [info script]]
    set s2 [file size test1]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-29.4 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -size 40
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    lappend result [file size test1]
} {0 0 40}
test io-29.5 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    fcopy $f1 $f2 -size -1
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size [info script]]
    set s2 [file size test1]
    if {"$s1" == "$s2"} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-29.6 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    set s0 [fcopy $f1 $f2 -size [expr [file size [info script]] + 5]]
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    set s1 [file size [info script]]
    set s2 [file size test1]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-29.7 {TclCopyChannel} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation lf -blocking 0
    fcopy $f1 $f2
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    set s1 [file size [info script]]
    set s2 [file size test1]
    close $f1
    close $f2
    if {"$s1" == "$s2"} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-29.8 {TclCopyChannel} {stdio} {
    removeFile test1
    removeFile pipe
    set f1 [open pipe w]
    fconfigure $f1 -translation lf
    puts $f1 {
	puts ready
	gets stdin
	set f1 [open [info script] r]
	fconfigure $f1 -translation lf
	puts [read $f1 100]
	close $f1
    }
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    fconfigure $f1 -translation lf
    gets $f1
    puts $f1 ready
    flush $f1
    set f2 [open test1 w]
    fconfigure $f2 -translation lf
    set s0 [fcopy $f1 $f2 -size 40]
    catch {close $f1}
    close $f2
    list $s0 [file size test1]
} {40 40}

test io-30.1 {CopyData} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -size 0
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    close $f1
    close $f2
    lappend result [file size test1]
} {0 0 0}
test io-30.2 {CopyData} {
    removeFile test1
    set f1 [open [info script]]
    set f2 [open test1 w]
    fconfigure $f1 -translation lf -blocking 0
    fconfigure $f2 -translation cr -blocking 0
    fcopy $f1 $f2 -command {set s0}
    set result [list [fconfigure $f1 -blocking] [fconfigure $f2 -blocking]]
    vwait s0
    close $f1
    close $f2
    set s1 [file size [info script]]
    set s2 [file size test1]
    if {("$s1" == "$s2") && ($s0 == $s1)} {
        lappend result ok
    }
    set result
} {0 0 ok}
test io-30.3 {CopyData: background read underflow} {unixOnly} {
    removeFile test1
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {
	puts ready
	flush stdout				;# Don't assume line buffered!
	fcopy stdin stdout -command { set x }
	vwait x
	set f [open test1 w]
	fconfigure $f -translation lf
	puts $f "done"
	close $f
    }
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    set result [gets $f1]
    puts $f1 line1
    flush $f1
    lappend result [gets $f1]
    puts $f1 line2
    flush $f1
    lappend result [gets $f1]
    close $f1
    after 500
    set f [open test1]
    lappend result [read $f]
    close $f
    set result
} "ready line1 line2 {done\n}"
test io-30.4 {CopyData: background write overflow} {unixOnly} {
    set big aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\n
    for {set x 0} {$x < 12} {incr x} {
	append big $big
    }
    removeFile test1
    removeFile pipe
    set f1 [open pipe w]
    puts $f1 {
	puts ready
	fcopy stdin stdout -command { set x }
	vwait x
	set f [open test1 w]
	fconfigure $f -translation lf
	puts $f "done"
	close $f
    }
    close $f1
    set f1 [open "|[list $tcltest pipe]" r+]
    set result [gets $f1]
    fconfigure $f1 -blocking 0
    puts $f1 $big
    flush $f1
    after 500
    set result ""
    fileevent $f1 read {
	append result [read $f1 1024]
	if {[string length $result] >= [string length $big]} {
	    set x done
	}
    }
    vwait x
    close $f1
    set big {}
    set x
} done

proc FcopyTestAccept {sock args} {
    after 1000 "close $sock"
}
proc FcopyTestDone {bytes {error {}}} {
    global fcopyTestDone
    if {[string length $error]} {
	set fcopyTestDone 1
    } else {
	set fcopyTestDone 0
    }
}
if [catch {socket -server FcopyTestAccept 2828} listen] {
    puts stderr "Skipping fcopy error test"
} else {
    test io-30.5 {CopyData: error during fcopy} {
	set in [open [info script]]	;# 126 K
	set out [socket localhost 2828]
	catch {unset fcopyTestDone}
	close $listen	;# This means the socket open never really succeeds
	fcopy $in $out -command FcopyTestDone
	if ![info exists fcopyTestDone] {
	    vwait fcopyTestDone		;# The error occurs here in the b.g.
	}
	close $in
	close $out
	set fcopyTestDone	;# 1 for error condition
    } 1
}
test io-30.6 {CopyData: error during fcopy} {stdio} {
    removeFile pipe
    removeFile test1
    catch {unset fcopyTestDone}
    set f1 [open pipe w]
    puts $f1 "exit 1"
    close $f1
    set in [open "|[list $tcltest pipe]" r+]
    set out [open test1 w]
    fcopy $in $out -command [list FcopyTestDone]
    if ![info exists fcopyTestDone] {
	vwait fcopyTestDone
    }
    catch {close $in}
    close $out
    set fcopyTestDone	;# 0 for plain end of file
} {0}

test io-31.1 {Recursive channel events} {socket} {
    # This test checks to see if file events are delivered during recursive
    # event loops when there is buffered data on the channel.

    proc accept {s a p} {
	global as
	fconfigure $s -translation lf
	puts $s "line 1\nline2\nline3"
	flush $s
	set as $s
    }
    proc readit {s next} {
	global result x
	lappend result $next
	if {$next == 1} {
	    fileevent $s readable [list readit $s 2]
	    vwait x
	}
	incr x
    }
    set ss [socket -server accept 2828]

    # We need to delay on some systems until the creation of the
    # server socket completes.

    set done 0
    for {set i 0} {$i < 10} {incr i} {
	if {![catch {set cs [socket [info hostname] 2828]}]} {
	    set done 1
	    break
	}
	after 100
    }
    if {$done == 0} {
	close $ss
	error "failed to connect to server"
    }
    set result {}
    set x 0
    vwait as
    fconfigure $cs -translation lf
    lappend result [gets $cs]
    fconfigure $cs -blocking off
    fileevent $cs readable [list readit $cs 1]
    set a [after 2000 { set x failure }]
    vwait x
    after cancel $a
    close $as
    close $ss
    close $cs
    list $result $x
} {{{line 1} 1 2} 2}
test io-31.2 {Testing for busy-wait in recursive channel events} {socket} {
    set s [socket -server accept 3939]
    proc accept {s a p} {
	global counter

	set counter 0
	fconfigure $s -blocking off -buffering line -translation lf
	fileevent $s readable "doit $s"
    }
    proc doit {s} {
	global counter

	incr counter
	set l [gets $s]
	if {"$l" == ""} {
	    fileevent $s readable "doit1 $s"
	    after 1000 newline
	}
    }
    proc doit1 {s} {
	global counter

	incr counter
	set l [gets $s]
	close $s
    }
    proc producer {} {
	global writer

	set writer [socket localhost 3939]
	fconfigure $writer -buffering line
	puts -nonewline $writer hello
	flush $writer
    }
    proc newline {} {
	global writer done

	puts $writer hello
	flush $writer
	set done 1
    }
    producer
    vwait done
    close $writer
    close $s
    set counter
} 1
test io-32.1 {ChannelEventScriptInvoker: deletion} {
    proc eventScript {fd} {
	close $fd
	error "planned error"
	set ::x whoops
    }
    proc bgerror {args} {
	set ::x got_error
    }
    set f [open fooBar w]
    fileevent $f writable [list eventScript $f]
    set x not_done
    vwait x
    set x
} {got_error}

test io-33.1 {ChannelTimerProc} {
    set f [open fooBar w]
    puts $f "this is a test"
    close $f
    set f [open fooBar r]
    testchannelevent $f add readable {
	read $f 1
	incr x
    }
    set x 0
    vwait x
    vwait x
    set result $x
    testchannelevent $f set 0 none
    after idle {set y done}
    vwait y
    lappend result $y
} {2 done}

removeFile fooBar
removeFile longfile
removeFile script
removeFile output
removeFile test1
removeFile pipe
removeFile my_script
removeFile foo
removeFile bar
removeFile test2
removeFile test3

file delete cat

set x ""
unset x
