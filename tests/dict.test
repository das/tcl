# This test file covers the dictionary object type and the dict
# command used to work with values of that type.
#
# This file contains a collection of tests for one or more of the Tcl
# built-in commands. Sourcing this file into Tcl runs the tests and
# generates output for errors.  No output means no errors were found.
#
# Copyright (c) 2003 Donal K. Fellows
# See the file "license.terms" for information on usage and redistribution
# of this file, and for a DISCLAIMER OF ALL WARRANTIES.
#
# RCS: @(#) $Id$

if {[lsearch [namespace children] ::tcltest] == -1} {
    package require tcltest
    namespace import -force ::tcltest::*
}

# Procedure to help check the contents of a dictionary.  Note that we
# can't just compare the string version because the order of the
# elements is (deliberately) not defined.  This is because it is
# dependent on the underlying hash table implementation and also
# potentially on the history of the value itself.  Net result: you
# cannot safely assume anything about the ordering of values.
proc getOrder {dictVal args} {
    foreach key $args {
	lappend result $key [dict get $dictVal $key]
    }
    lappend result [dict size $dictVal]
    return $result
}

test dict-1.1 {dict command basic syntax} {
    list [catch {dict} msg] $msg
} {1 {wrong # args: should be "dict subcommand ?arg ...?"}}
test dict-1.2 {dict command basic syntax} {
    list [catch {dict ?} msg] $msg
} {1 {bad subcommand "?": must be append, create, exists, filter, for, get, incr, info, keys, lappend, remove, replace, set, size, unset, or values}}

test dict-2.1 {dict create command} {
    dict create
} {}
test dict-2.2 {dict create command} {
    dict create a b
} {a b}
test dict-2.3 {dict create command} {
    set result {}
    set dict [dict create a b c d]
    # Can't compare directly as ordering of values is undefined
    foreach key {a c} {
	set idx [lsearch -exact $dict $key]
	if {$idx & 1} {
	    error "found $key at odd index $idx in $dict"
	}
	lappend result [lindex $dict [expr {$idx+1}]]
    }
    set result
} {b d}
test dict-2.4 {dict create command} {
    list [catch {dict create a} msg] $msg
} {1 {wrong # args: should be "dict create ?key value ...?"}}
test dict-2.5 {dict create command} {
    list [catch {dict create a b c} msg] $msg
} {1 {wrong # args: should be "dict create ?key value ...?"}}
test dict-2.6 {dict create command - initialse refcount field!} {
    # Bug 715751 will show up in memory debuggers like purify
    for {set i 0} {$i<10} {incr i} { 
	set dictv [dict create a 0] 
	set share [dict values $dictv] 
	list [dict incr dictv a] 
    } 
} {}
test dict-2.7 {dict create command - #-quoting in string rep} {
    dict create # #comment
} {{#} #comment}
test dict-2.8 {dict create command - #-quoting in string rep} -body {
    dict create #a x #b x
} -match glob -result {{#?} x #? x}

test dict-3.1 {dict get command} {dict get {a b} a} b
test dict-3.2 {dict get command} {dict get {a b c d} a} b
test dict-3.3 {dict get command} {dict get {a b c d} c} d
test dict-3.4 {dict get command} {
    list [catch {dict get {a b c d} b} msg] $msg
} {1 {key "b" not known in dictionary}}
test dict-3.5 {dict get command} {dict get {a {p q r s} b {u v x y}} a p} q
test dict-3.6 {dict get command} {dict get {a {p q r s} b {u v x y}} a r} s
test dict-3.7 {dict get command} {dict get {a {p q r s} b {u v x y}} b u} v
test dict-3.8 {dict get command} {dict get {a {p q r s} b {u v x y}} b x} y
test dict-3.9 {dict get command} {
    list [catch {dict get {a {p q r s} b {u v x y}} a z} msg] $msg
} {1 {key "z" not known in dictionary}}
test dict-3.10 {dict get command} {
    list [catch {dict get {a {p q r s} b {u v x y}} c z} msg] $msg
} {1 {key "c" not known in dictionary}}
test dict-3.11 {dict get command} {dict get [dict create a b c d] a} b
test dict-3.12 {dict get command} {
    list [catch {dict get} msg] $msg
} {1 {wrong # args: should be "dict get dictionary ?key key ...?"}}
test dict-3.13 {dict get command} {
    set dict [dict get {a b c d}]
    if {$dict eq "a b c d"} {
	subst OK
    } elseif {$dict eq "c d a b"} {
	subst OK
    } else {
	set dict
    }
} OK
test dict-3.14 {dict get command} {
    list [catch {dict get {a b c d} a c} msg] $msg
} {1 {missing value to go with key}}

test dict-4.1 {dict replace command} {
    getOrder [dict replace {a b c d}] a c
} {a b c d 2}
test dict-4.2 {dict replace command} {
    getOrder [dict replace {a b c d} e f] a c e
} {a b c d e f 3}
test dict-4.3 {dict replace command} {
    getOrder [dict replace {a b c d} c f] a c
} {a b c f 2}
test dict-4.4 {dict replace command} {
    getOrder [dict replace {a b c d} c x a y] a c
} {a y c x 2}
test dict-4.5 {dict replace command} {
    list [catch {dict replace} msg] $msg
} {1 {wrong # args: should be "dict replace dictionary ?key value ...?"}}
test dict-4.6 {dict replace command} {
    list [catch {dict replace {a a} a} msg] $msg
} {1 {wrong # args: should be "dict replace dictionary ?key value ...?"}}
test dict-4.7 {dict replace command} {
    list [catch {dict replace {a a a} a b} msg] $msg
} {1 {missing value to go with key}}
test dict-4.8 {dict replace command} {
    list [catch {dict replace [list a a a] a b} msg] $msg
} {1 {missing value to go with key}}
test dict-4.9 {dict replace command} {dict replace [list a a] a b} {a b}

test dict-5.1 {dict remove command} {dict remove {a b c d} a} {c d}
test dict-5.2 {dict remove command} {dict remove {a b c d} c} {a b}
test dict-5.3 {dict remove command} {dict remove {a b c d} a c} {}
test dict-5.4 {dict remove command} {dict remove {a b c d} c a} {}
test dict-5.5 {dict remove command} {
    getOrder [dict remove {a b c d}] a c
} {a b c d 2}
test dict-5.6 {dict remove command} {dict remove {a b} c} {a b}
test dict-5.7 {dict remove command} {
    list [catch {dict remove} msg] $msg
} {1 {wrong # args: should be "dict remove dictionary ?key ...?"}}

test dict-6.1 {dict keys command} {dict keys {a b}} a
test dict-6.2 {dict keys command} {dict keys {c d}} c
test dict-6.3 {dict keys command} {lsort [dict keys {a b c d}]} {a c}
test dict-6.4 {dict keys command} {dict keys {a b c d} a} a
test dict-6.5 {dict keys command} {dict keys {a b c d} c} c
test dict-6.6 {dict keys command} {dict keys {a b c d} e} {}
test dict-6.7 {dict keys command} {lsort [dict keys {a b c d ca da} c*]} {c ca}
test dict-6.8 {dict keys command} {
    list [catch {dict keys} msg] $msg
} {1 {wrong # args: should be "dict keys dictionary ?pattern?"}}
test dict-6.9 {dict keys command} {
    list [catch {dict keys {} a b} msg] $msg
} {1 {wrong # args: should be "dict keys dictionary ?pattern?"}}
test dict-6.10 {dict keys command} {
    list [catch {dict keys a} msg] $msg
} {1 {missing value to go with key}}

test dict-7.1 {dict values command} {dict values {a b}} b
test dict-7.2 {dict values command} {dict values {c d}} d
test dict-7.3 {dict values command} {lsort [dict values {a b c d}]} {b d}
test dict-7.4 {dict values command} {dict values {a b c d} b} b
test dict-7.5 {dict values command} {dict values {a b c d} d} d
test dict-7.6 {dict values command} {dict values {a b c d} e} {}
test dict-7.7 {dict values command} {lsort [dict values {a b c d ca da} d*]} {d da}
test dict-7.8 {dict values command} {
    list [catch {dict values} msg] $msg
} {1 {wrong # args: should be "dict values dictionary ?pattern?"}}
test dict-7.9 {dict values command} {
    list [catch {dict values {} a b} msg] $msg
} {1 {wrong # args: should be "dict values dictionary ?pattern?"}}
test dict-7.10 {dict values command} {
    list [catch {dict values a} msg] $msg
} {1 {missing value to go with key}}

test dict-8.1 {dict size command} {dict size {}} 0
test dict-8.2 {dict size command} {dict size {a b}} 1
test dict-8.3 {dict size command} {dict size {a b c d}} 2
test dict-8.4 {dict size command} {
    list [catch {dict size} msg] $msg
} {1 {wrong # args: should be "dict size dictionary"}}
test dict-8.5 {dict size command} {
    list [catch {dict size a b} msg] $msg
} {1 {wrong # args: should be "dict size dictionary"}}
test dict-8.6 {dict size command} {
    list [catch {dict size a} msg] $msg
} {1 {missing value to go with key}}

test dict-9.1 {dict exists command} {dict exists {a b} a} 1
test dict-9.2 {dict exists command} {dict exists {a b} b} 0
test dict-9.3 {dict exists command} {dict exists {a {b c}} a b} 1
test dict-9.4 {dict exists command} {dict exists {a {b c}} a c} 0
test dict-9.5 {dict exists command} {
    list [catch {dict exists {a {b c}} b c} msg] $msg
} {1 {key "b" not known in dictionary}}
test dict-9.6 {dict exists command} {
    list [catch {dict exists {a {b c d}} a c} msg] $msg
} {1 {missing value to go with key}}
test dict-9.7 {dict exists command} {
    list [catch {dict exists} msg] $msg
} {1 {wrong # args: should be "dict exists dictionary key ?key ...?"}}
test dict-9.8 {dict exists command} {
    list [catch {dict exists {}} msg] $msg
} {1 {wrong # args: should be "dict exists dictionary key ?key ...?"}}

test dict-10.1 {dict info command} {
    # Actual string returned by this command is undefined; it is
    # intended for human consumption and not for use by scripts.
    dict info {}
    subst {}
} {}
test dict-10.2 {dict info command} {
    list [catch {dict info} msg] $msg
} {1 {wrong # args: should be "dict info dictionary"}}
test dict-10.3 {dict info command} {
    list [catch {dict info {} x} msg] $msg
} {1 {wrong # args: should be "dict info dictionary"}}
test dict-10.4 {dict info command} {
    list [catch {dict info x} msg] $msg
} {1 {missing value to go with key}}

test dict-11.1 {dict incr command: unshared value} {
    set dictv [dict create \
	    a [string index "=0=" 1] \
	    b [expr {1+2}] \
	    c [expr {wide(0x80000000)+1}]]
    getOrder [dict incr dictv a] a b c
} {a 1 b 3 c 2147483649 3}
test dict-11.2 {dict incr command: unshared value} {
    set dictv [dict create \
	    a [string index "=0=" 1] \
	    b [expr {1+2}] \
	    c [expr {wide(0x80000000)+1}]]
    getOrder [dict incr dictv b] a b c
} {a 0 b 4 c 2147483649 3}
test dict-11.3 {dict incr command: unshared value} {
    set dictv [dict create \
	    a [string index "=0=" 1] \
	    b [expr {1+2}] \
	    c [expr {wide(0x80000000)+1}]]
    getOrder [dict incr dictv c] a b c
} {a 0 b 3 c 2147483650 3}
test dict-11.4 {dict incr command: shared value} {
    set dictv [dict create a 0 b [expr {1+2}] c [expr {wide(0x80000000)+1}]]
    set sharing [dict values $dictv]
    getOrder [dict incr dictv a] a b c
} {a 1 b 3 c 2147483649 3}
test dict-11.5 {dict incr command: shared value} {
    set dictv [dict create a 0 b [expr {1+2}] c [expr {wide(0x80000000)+1}]]
    set sharing [dict values $dictv]
    getOrder [dict incr dictv b] a b c
} {a 0 b 4 c 2147483649 3}
test dict-11.6 {dict incr command: shared value} {
    set dictv [dict create a 0 b [expr {1+2}] c [expr {wide(0x80000000)+1}]]
    set sharing [dict values $dictv]
    getOrder [dict incr dictv c] a b c
} {a 0 b 3 c 2147483650 3}
test dict-11.7 {dict incr command: unknown values} {
    set dictv [dict create a 0 b [expr {1+2}] c [expr {wide(0x80000000)+1}]]
    getOrder [dict incr dictv d] a b c d
} {a 0 b 3 c 2147483649 d 1 4}
test dict-11.8 {dict incr command} {
    set dictv {a 1}
    dict incr dictv a 2
} {a 3}
test dict-11.9 {dict incr command} {
    set dictv {a dummy}
    list [catch {dict incr dictv a} msg] $msg
} {1 {expected integer but got "dummy"}}
test dict-11.10 {dict incr command} {
    set dictv {a 1}
    list [catch {dict incr dictv a dummy} msg] $msg
} {1 {expected integer but got "dummy"}}
test dict-11.11 {dict incr command} {
    catch {unset dictv}
    dict incr dictv a
} {a 1}
test dict-11.12 {dict incr command} {
    set dictv a
    list [catch {dict incr dictv a} msg] $msg
} {1 {missing value to go with key}}
test dict-11.13 {dict incr command} {
    set dictv a
    list [catch {dict incr dictv a a a} msg] $msg
} {1 {wrong # args: should be "dict incr varName key ?increment?"}}
test dict-11.14 {dict incr command} {
    set dictv a
    list [catch {dict incr dictv} msg] $msg
} {1 {wrong # args: should be "dict incr varName key ?increment?"}}
test dict-11.15 {dict incr command: write failure} {
    catch {unset dictVar}
    set dictVar(block) {}
    set result [list [catch {dict incr dictVar a} msg] $msg]
    catch {unset dictVar}
    set result
} {1 {can't set "dictVar": variable is array}}

test dict-12.1 {dict lappend command} {
    set dictv {a a}
    dict lappend dictv a
} {a a}
test dict-12.2 {dict lappend command} {
    set dictv {a a}
    set sharing [dict values $dictv]
    dict lappend dictv a b
} {a {a b}}
test dict-12.3 {dict lappend command} {
    set dictv {a a}
    dict lappend dictv a b c
} {a {a b c}}
test dict-12.2 {dict lappend command} {
    set dictv [dict create a [string index =a= 1]]
    dict lappend dictv a b
} {a {a b}}
test dict-12.4 {dict lappend command} {
    set dictv {}
    dict lappend dictv a x y z
} {a {x y z}}
test dict-12.5 {dict lappend command} {
    catch {unset dictv}
    dict lappend dictv a b
} {a b}
test dict-12.6 {dict lappend command} {
    set dictv a
    list [catch {dict lappend dictv a a} msg] $msg
} {1 {missing value to go with key}}
test dict-12.7 {dict lappend command} {
    list [catch {dict lappend} msg] $msg
} {1 {wrong # args: should be "dict lappend varName key ?value ...?"}}
test dict-12.8 {dict lappend command} {
    list [catch {dict lappend dictv} msg] $msg
} {1 {wrong # args: should be "dict lappend varName key ?value ...?"}}
test dict-12.9 {dict lappend command} {
    set dictv [dict create a "\{"]
    list [catch {dict lappend dictv a a} msg] $msg
} {1 {unmatched open brace in list}}
test dict-12.10 {dict lappend command: write failure} {
    catch {unset dictVar}
    set dictVar(block) {}
    set result [list [catch {dict lappend dictVar a x} msg] $msg]
    catch {unset dictVar}
    set result
} {1 {can't set "dictVar": variable is array}}

test dict-13.1 {dict append command} {
    set dictv {a a}
    dict append dictv a
} {a a}
test dict-13.2 {dict append command} {
    set dictv {a a}
    set sharing [dict values $dictv]
    dict append dictv a b
} {a ab}
test dict-13.3 {dict append command} {
    set dictv {a a}
    dict append dictv a b c
} {a abc}
test dict-13.2 {dict append command} {
    set dictv [dict create a [string index =a= 1]]
    dict append dictv a b
} {a ab}
test dict-13.4 {dict append command} {
    set dictv {}
    dict append dictv a x y z
} {a xyz}
test dict-13.5 {dict append command} {
    catch {unset dictv}
    dict append dictv a b
} {a b}
test dict-13.6 {dict append command} {
    set dictv a
    list [catch {dict append dictv a a} msg] $msg
} {1 {missing value to go with key}}
test dict-13.7 {dict append command} {
    list [catch {dict append} msg] $msg
} {1 {wrong # args: should be "dict append varName key ?value ...?"}}
test dict-13.8 {dict append command} {
    list [catch {dict append dictv} msg] $msg
} {1 {wrong # args: should be "dict append varName key ?value ...?"}}
test dict-13.9 {dict append command: write failure} {
    catch {unset dictVar}
    set dictVar(block) {}
    set result [list [catch {dict append dictVar a x} msg] $msg]
    catch {unset dictVar}
    set result
} {1 {can't set "dictVar": variable is array}}

test dict-14.1 {dict for command: syntax} {
    list [catch {dict for} msg] $msg
} {1 {wrong # args: should be "dict for {keyVar valueVar} dictionary script"}}
test dict-14.2 {dict for command: syntax} {
    list [catch {dict for x} msg] $msg
} {1 {wrong # args: should be "dict for {keyVar valueVar} dictionary script"}}
test dict-14.3 {dict for command: syntax} {
    list [catch {dict for x x} msg] $msg
} {1 {wrong # args: should be "dict for {keyVar valueVar} dictionary script"}}
test dict-14.4 {dict for command: syntax} {
    list [catch {dict for x x x x} msg] $msg
} {1 {wrong # args: should be "dict for {keyVar valueVar} dictionary script"}}
test dict-14.5 {dict for command: syntax} {
    list [catch {dict for x x x} msg] $msg
} {1 {must have exactly two variable names}}
test dict-14.6 {dict for command: syntax} {
    list [catch {dict for {x x x} x x} msg] $msg
} {1 {must have exactly two variable names}}
test dict-14.7 {dict for command: syntax} {
    list [catch {dict for "\{x" x x} msg] $msg
} {1 {unmatched open brace in list}}
test dict-14.8 {dict for command} {
    # This test confirms that [dict keys], [dict values] and [dict for]
    # all traverse a dictionary in the same order.
    set dictv {a A b B c C}
    set keys {}
    set values {}
    dict for {k v} $dictv {
	lappend keys $k
	lappend values $v
    }
    set result [expr {
	$keys eq [dict keys $dictv] && $values eq [dict values $dictv]
    }]
    expr {$result ? "YES" : [list "NO" $dictv $keys $values]}
} YES
test dict-14.9 {dict for command} {
    dict for {k v} {} {
	error "unexpected execution of 'dict for' body"
    }
} {}
test dict-14.10 {dict for command: script results} {
    set times 0
    dict for {k v} {a a b b} {
	incr times
	continue
	error "shouldn't get here"
    }
    set times
} 2
test dict-14.11 {dict for command: script results} {
    set times 0
    dict for {k v} {a a b b} {
	incr times
	break
	error "shouldn't get here"
    }
    set times
} 1
test dict-14.12 {dict for command: script results} {
    set times 0
    list [catch {
	dict for {k v} {a a b b} {
	    incr times
	    error test
	}
    } msg] $msg $times $::errorInfo
} {1 test 1 {test
    while executing
"error test"
    ("dict for" body line 3)
    invoked from within
"dict for {k v} {a a b b} {
	    incr times
	    error test
	}"}}
test dict-14.13 {dict for command: script results} {
    proc dicttest {} {
	rename dicttest {}
	dict for {k v} {a b} {
	    return ok,$k,$v
	    error "skipped return completely"
	}
	error "return didn't go far enough"
    }
    dicttest
} ok,a,b
test dict-14.14 {dict for command: handle representation loss} {
    set dictVar {a b c d e f g h}
    set keys {}
    set values {}
    dict for {k v} $dictVar {
	if {[llength $dictVar]} {
	    lappend keys $k
	    lappend values $v
	}
    }
    list [lsort $keys] [lsort $values]
} {{a c e g} {b d f h}}
test dict-14.15 {dict for command: keys are unique and iterated over once only} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    catch {unset accum}
    array set accum {}
    dict for {k v} $dictVar {
	append accum($k) $v,
    }
    set result [lsort [array names accum]]
    lappend result :
    foreach k $result {
	catch {lappend result $accum($k)}
    }
    catch {unset accum}
    set result
} {a1 a2 b1 b2 bar foo : a, b, c, d, foo, bar,}
# There's probably a lot more tests to add here.  Really ought to use
# a coverage tool for this job...

test dict-15.1 {dict set command} {
    set dictVar {}
    dict set dictVar a x
} {a x}
test dict-15.2 {dict set command} {
    set dictvar {a {}}
    dict set dictvar a b x
} {a {b x}}
test dict-15.3 {dict set command} {
    set dictvar {a {b {}}}
    dict set dictvar a b c x
} {a {b {c x}}}
test dict-15.4 {dict set command} {
    set dictVar {a y}
    dict set dictVar a x
} {a x}
test dict-15.5 {dict set command} {
    set dictVar {a {b y}}
    dict set dictVar a b x
} {a {b x}}
test dict-15.6 {dict set command} {
    set dictVar {a {b {c y}}}
    dict set dictVar a b c x
} {a {b {c x}}}
test dict-15.7 {dict set command: no path creation} {
    set dictVar {}
    list [catch {dict set dictVar a b x} msg] $msg
} {1 {key "a" not known in dictionary}}
test dict-15.8 {dict set command: creates variables} {
    catch {unset dictVar}
    dict set dictVar a x
    set dictVar
} {a x}
test dict-15.9 {dict set command: write failure} {
    catch {unset dictVar}
    set dictVar(block) {}
    set result [list [catch {dict set dictVar a x} msg] $msg]
    catch {unset dictVar}
    set result
} {1 {can't set "dictVar": variable is array}}
test dict-15.10 {dict set command: syntax} {
    list [catch {dict set} msg] $msg
} {1 {wrong # args: should be "dict set varName key ?key ...? value"}}
test dict-15.11 {dict set command: syntax} {
    list [catch {dict set a} msg] $msg
} {1 {wrong # args: should be "dict set varName key ?key ...? value"}}
test dict-15.12 {dict set command: syntax} {
    list [catch {dict set a a} msg] $msg
} {1 {wrong # args: should be "dict set varName key ?key ...? value"}}
test dict-15.13 {dict set command} {
    set dictVar a
    list [catch {dict set dictVar b c} msg] $msg
} {1 {missing value to go with key}}

test dict-16.1 {dict unset command} {
    set dictVar {a b c d}
    dict unset dictVar a
} {c d}
test dict-16.2 {dict unset command} {
    set dictVar {a b c d}
    dict unset dictVar c
} {a b}
test dict-16.3 {dict unset command} {
    set dictVar {a b}
    dict unset dictVar c
} {a b}
test dict-16.4 {dict unset command} {
    set dictVar {a {b c d e}}
    dict unset dictVar a b
} {a {d e}}
test dict-16.5 {dict unset command} {
    set dictVar a
    list [catch {dict unset dictVar a} msg] $msg
} {1 {missing value to go with key}}
test dict-16.6 {dict unset command} {
    set dictVar {a b}
    list [catch {dict unset dictVar c d} msg] $msg
} {1 {key "c" not known in dictionary}}
test dict-16.7 {dict unset command} {
    catch {unset dictVar}
    list [info exists dictVar] [dict unset dictVar a] [info exists dictVar]
} {0 {} 1}
test dict-16.8 {dict unset command} {
    list [catch {dict unset dictVar} msg] $msg
} {1 {wrong # args: should be "dict unset varName key ?key ...?"}}
test dict-16.9 {dict unset command: write failure} {
    catch {unset dictVar}
    set dictVar(block) {}
    set result [list [catch {dict unset dictVar a} msg] $msg]
    catch {unset dictVar}
    set result
} {1 {can't set "dictVar": variable is array}}

test dict-17.1 {dict filter command: key} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    dict filter $dictVar key a2
} {a2 b}
test dict-17.2 {dict filter command: key} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    dict size [dict filter $dictVar key *]
} 6
test dict-17.3 {dict filter command: key} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    getOrder [dict filter $dictVar key ???] bar foo
} {bar foo foo bar 2}
test dict-17.4 {dict filter command: key} {
    list [catch {dict filter {} key} msg] $msg
} {1 {wrong # args: should be "dict filter dictionary key globPattern"}}
test dict-17.5 {dict filter command: key} {
    list [catch {dict filter {} key a a} msg] $msg
} {1 {wrong # args: should be "dict filter dictionary key globPattern"}}
test dict-17.6 {dict filter command: value} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    dict filter $dictVar value c
} {b1 c}
test dict-17.7 {dict filter command: value} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    dict size [dict filter $dictVar value *]
} 6
test dict-17.8 {dict filter command: value} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    getOrder [dict filter $dictVar value ???] bar foo
} {bar foo foo bar 2}
test dict-17.9 {dict filter command: value} {
    list [catch {dict filter {} value} msg] $msg
} {1 {wrong # args: should be "dict filter dictionary value globPattern"}}
test dict-17.10 {dict filter command: value} {
    list [catch {dict filter {} value a a} msg] $msg
} {1 {wrong # args: should be "dict filter dictionary value globPattern"}}
test dict-17.11 {dict filter command: script} {
    set dictVar {a1 a a2 b b1 c b2 d foo bar bar foo}
    set n 0
    list [getOrder [dict filter $dictVar script {k v} {
	incr n
	expr {[string length $k] == [string length $v]}
    }] bar foo] $n
} {{bar foo foo bar 2} 6}
test dict-17.12 {dict filter command: script} {
    list [catch {dict filter {a b} script {k v} {concat $k $v}} msg] $msg
} {1 {expected boolean value but got "a b"}}
test dict-17.13 {dict filter command: script} {
    list [catch {dict filter {a b} script {k v} {error x}} msg] $msg \
	    $::errorInfo
} {1 x {x
    while executing
"error x"
    ("dict filter" script line 1)
    invoked from within
"dict filter {a b} script {k v} {error x}"}}
test dict-17.14 {dict filter command: script} {
    set n 0
    list [dict filter {a b c d} script {k v} {
	incr n
	break
	error boom!
    }] $n
} {{} 1}
test dict-17.15 {dict filter command: script} {
    set n 0
    list [dict filter {a b c d} script {k v} {
	incr n
	continue
	error boom!
    }] $n
} {{} 2}
test dict-17.16 {dict filter command: script} {
    proc dicttest {} {
	rename dicttest {}
	dict filter {a b} script {k v} {
	    return ok,$k,$v
	    error "skipped return completely"
	}
	error "return didn't go far enough"
    }
    dicttest
} ok,a,b
test dict-17.17 {dict filter command: script} {
    dict filter {a b} script {k k} {continue}
    set k
} b
test dict-17.18 {dict filter command: script} {
    list [catch {dict filter {a b} script {k k}} msg] $msg
} {1 {wrong # args: should be "dict filter dictionary script {keyVar valueVar} filterScript"}}
test dict-17.19 {dict filter command: script} {
    list [catch {dict filter {a b} script k {continue}} msg] $msg
} {1 {must have exactly two variable names}}
test dict-17.20 {dict filter command: script} {
    list [catch {dict filter {a b} script "\{k v" {continue}} msg] $msg
} {1 {unmatched open brace in list}}
test dict-17.21 {dict filter command} {
    list [catch {dict filter {a b}} msg] $msg
} {1 {wrong # args: should be "dict filter dictionary filterType ..."}}
test dict-17.22 {dict filter command} {
    list [catch {dict filter {a b} JUNK} msg] $msg
} {1 {bad filterType "JUNK": must be key, script, or value}}
test dict-17.23 {dict filter command} {
    list [catch {dict filter a key *} msg] $msg
} {1 {missing value to go with key}}

# cleanup
::tcltest::cleanupTests
return

# Local Variables:
# mode: tcl
# End:
